<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-24T11:31:35.359Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>guoziyi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AJAX</title>
    <link href="http://yoursite.com/2018/04/24/AJAX/"/>
    <id>http://yoursite.com/2018/04/24/AJAX/</id>
    <published>2018-04-24T11:29:47.000Z</published>
    <updated>2018-04-24T11:31:35.359Z</updated>
    
    <content type="html"><![CDATA[<p>什么是ajax：<br>AJAX是“Asynchronous JavaScript and XML”的缩写，异步JavaScript和xml</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是ajax：&lt;br&gt;AJAX是“Asynchronous JavaScript and XML”的缩写，异步JavaScript和xml&lt;/p&gt;

      
    
    </summary>
    
      <category term="AJAX" scheme="http://yoursite.com/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>面试总结之js</title>
    <link href="http://yoursite.com/2018/04/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%933/"/>
    <id>http://yoursite.com/2018/04/22/前端面试总结3/</id>
    <published>2018-04-22T14:04:47.000Z</published>
    <updated>2018-05-15T04:11:58.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js的特点："><a href="#js的特点：" class="headerlink" title="js的特点："></a>js的特点：</h3><p>脚本语言解释性单线程<br>采用了二进制浮点数表示法，并不能精准的表示0.1这样的简单数字</p><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>基本类型number string undefined null boolen（在栈中，可以直接访问）<br>引用类型object function array date regexp（在堆中，实际存放了一个指针，操作是对引用的操作）</p><h3 id="变量声明提升-函数声明提升："><a href="#变量声明提升-函数声明提升：" class="headerlink" title="变量声明提升,函数声明提升："></a>变量声明提升,函数声明提升：</h3><p>在js中所有声明都会提升在顶部，赋值不提升。函数声明提升在变量声明提升之前，变量声明不会覆盖函数声明。但是赋值会覆盖。判断同名函数声明和变量声明在使用前是否有赋值语句</p><h3 id="作用域链，闭包"><a href="#作用域链，闭包" class="headerlink" title="作用域链，闭包"></a>作用域链，闭包</h3><p>作用域链是指js中内部函数可以访问外部函数中的变量，外部不能访问内部。当一个函数执行之前会创建一个对象存储函数的变量，然后挂载在作用域链中。<br>如果一个内部函数被作为一个返回值返回，那么外部函数虽然被销毁了，内部函数却不会被销毁并且依然会保存外部函数执行器上下文，这样就形成了闭包。如果这个函数被返回后但是没有被接收，那么这个闭包也没有意义。</p><h3 id="闭包的优缺点："><a href="#闭包的优缺点：" class="headerlink" title="闭包的优缺点："></a>闭包的优缺点：</h3><p>优点是由于外部不能访问内部，所以可以设计私有的方法和变量。方便调用上下文变量<br>缺点就是会导致内存泄漏(采用立即执行函数解决闭包)</p><h3 id="事件冒泡事件捕获："><a href="#事件冒泡事件捕获：" class="headerlink" title="事件冒泡事件捕获："></a>事件冒泡事件捕获：</h3><p>当一个事件源本身无法处理该事件的时候，会将该事件逐层向外传递就是事件冒泡<br>事件捕获是事件冒泡相反的顺序</p><h3 id="事件监听："><a href="#事件监听：" class="headerlink" title="事件监听："></a>事件监听：</h3><p>标准浏览器：addEventListener()/removeEventListener()<br>第一个参数是事件类型，第二个参数是回调函数（即用来执行的代码），第三个参数默认为false，当改为true时，代表事件捕获；<br>ie:attachEvent()/detachEvent()<br>句柄绑定：onclick=function（）{}</p><h3 id="事件对象和目标对象："><a href="#事件对象和目标对象：" class="headerlink" title="事件对象和目标对象："></a>事件对象和目标对象：</h3><p>标准浏览器：event    event.target<br>ie：window.event     window.event.srcElement<br>target指向触发事件的对象，currentTarget指向处理事件的对象</p><h3 id="阻止默认事件："><a href="#阻止默认事件：" class="headerlink" title="阻止默认事件："></a>阻止默认事件：</h3><p>标准：preventDafult<br>ie：returnValue=false</p><h3 id="阻止事件冒泡："><a href="#阻止事件冒泡：" class="headerlink" title="阻止事件冒泡："></a>阻止事件冒泡：</h3><p>标准：event.stopPropagation()<br>ie:window.event.cancelBubble()</p><h3 id="获取元素方法："><a href="#获取元素方法：" class="headerlink" title="获取元素方法："></a>获取元素方法：</h3><p>1.getElementById()<br>2.getElementsByClassName()//实时<br>3.getElementsByName()//实时<br>4.getElementBysTagName()//实时<br>5.querySelectorAll()//非实时更新的，如果节点树发生变化，无法更新<br>6.querySelector()//非实时更新的，如果节点树发生变化，无法更新</p><h3 id="dom操作"><a href="#dom操作" class="headerlink" title="dom操作"></a>dom操作</h3><p>element.append/removeChild    向元素添加/删除子节点，作为最后一个子节点。<br>element.first/lastChild    返回元素的首/尾个子元素。<br>element.previous/nextSibling    返回位于相同节点树层级的前/后一个元素。<br>element.childNodes    返回元素子节点的 NodeList。<br>element.parentNode    返回元素的父节点。</p><h3 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h3><p>js中表达式是立即执行的，如果我们把一个函数变成一个表达式，就是自执行函数，不需要调用直接执行。自执行函数内部作用域受保护，所以一般可以用作命名空间，如jquery。也可以用来处理闭包问题</p><h3 id="遍历数组的方法："><a href="#遍历数组的方法：" class="headerlink" title="遍历数组的方法："></a>遍历数组的方法：</h3><p>for,for in,for each(不支持break)</p><h3 id="合并数组："><a href="#合并数组：" class="headerlink" title="合并数组："></a>合并数组：</h3><p>…<br>concat</p><h3 id="数组和伪数组的区别："><a href="#数组和伪数组的区别：" class="headerlink" title="数组和伪数组的区别："></a>数组和伪数组的区别：</h3><p>伪数组只有length属性，不具备数组的方法。<br>用 Array.isArray(arr)判断是否是数组类型</p><h3 id="深拷贝浅拷贝（-Object-assign-是浅拷贝）"><a href="#深拷贝浅拷贝（-Object-assign-是浅拷贝）" class="headerlink" title="深拷贝浅拷贝（ Object.assign()是浅拷贝）"></a>深拷贝浅拷贝（ Object.assign()是浅拷贝）</h3><p>浅拷贝只复制了一层拷贝，即只复制了简单类型<br>深拷贝是层级赋值，遍历所有对象进行复制</p><h3 id="ES6新增数据类型："><a href="#ES6新增数据类型：" class="headerlink" title="ES6新增数据类型："></a>ES6新增数据类型：</h3><p>Symbol:避免属性名冲突 保证该变量独一无二。<br>let s=Symbol();(不能使用new)<br>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。<br>它们的区别是：前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。<br>（Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值）</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数:"></a>箭头函数:</h3><p>箭头函数中的this是定义是所在的对象，箭头函数是匿名函数的，所以要注意变量声明提升的问题哦</p><h3 id="匿名函数优缺点："><a href="#匿名函数优缺点：" class="headerlink" title="匿名函数优缺点："></a>匿名函数优缺点：</h3><p>优点：不会污染全局变量<br>缺点：绑定事件时无法解绑</p><h3 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h3><p>let:块级作用域只在该块区域有效，可以阻止闭包，会导致暂时性死域（如果有全局的变量同名，那么不论在let前后永远都无法访问全局变量），一个区域不接受同名变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">argument</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">let</span> a=<span class="number">4</span></span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">    n();<span class="comment">//undefined undefined</span></span><br></pre></td></tr></table></figure></p><p>const:声明一个只读的常量，如果是一个对象可以正常的进行添加属性</p><h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>1.es6中的class extend继承<br>2.原型链：通过new父级构造函数的方式，并且prototype改为父级，这样自己可以访问所有父级的所有属性（浪费）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br></pre></td></tr></table></figure></p><p>3.用call和apply写构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;Father.call(<span class="keyword">this</span>)&#125;</span><br></pre></td></tr></table></figure></p><p>4.共享原型：prototype相同（无法更改，一个改都改了）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Son.prototype = Father.prototype;</span><br></pre></td></tr></table></figure></p><p>5.圣杯模型：创建一个空函数，空函数的原型等于父级原型，子级的原型等于new这个空函数。这样两者修改原型不会受影响。修改原型上构造函数为自身，保存一下原型uber为父级<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">C,P</span>)</span>&#123;</span><br><span class="line">        F.prototype = P.prototype;</span><br><span class="line">        C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">        C.prototype.constructor = C;</span><br><span class="line">        C.prototype.uber = P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>6.object.create() ：在原型上生成新的对象的实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Father);</span><br></pre></td></tr></table></figure></p><h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h3><p>改变this指向，传参不同（可以实现一个对象调用另一个对象的方法），call一个个传，apply传数组，并且他俩立即执行，bind返回的是一个函数，可以手动执行</p><h3 id="new是什么？"><a href="#new是什么？" class="headerlink" title="new是什么？"></a>new是什么？</h3><p>当我们要创建一个对象的实例时。我们要去继承这个对象的原型。那么new的作用就是帮你自动完成4个步骤。<br>①帮你创建一个新对象。var obj = new Object();<br>②帮你绑定原型。obj.<strong>proto</strong> = Object.prototype 将新对象的<strong>proto</strong>属性指向构造函数的prototype<br>③帮你将this指向新对象。<br>④帮你return新对象。但在这里注意构造函数是否有返回值。如果构造函数的返回值为基本数据类型（number，string，boolean，undefined，null）则返回临新对象。如果构造函数的返回值为对象类型，则返回这个对象类型。</p><h3 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h3><p>this是Javascript语言的一个关键字它代表函数运行时，自动生成的一个内部对象。</p><h3 id="DOM-BOM："><a href="#DOM-BOM：" class="headerlink" title="DOM/BOM："></a>DOM/BOM：</h3><p>dom：文档对象模型。将文档当做对象看，用来获取或设置文档中标签的属性。<br>bom：浏览器对象模型。将浏览器当做对象看，用来获取或设置浏览器的属性。</p><h3 id="异步方法："><a href="#异步方法：" class="headerlink" title="异步方法："></a>异步方法：</h3><p>1.计时器和回调函数，<br>2.jquery的$deferred() when().done()<br>3.promise<br>4.defer/async异步加载脚本<br>5.generator ：用function*创建函数 yield中写每一步的操作。实例对象.next()执行</p><h3 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h3><p>prototype是函数特有的属性，<strong>proto</strong>是所有对象的属性。<br>js中万物皆对象，所以一切对象都有这个隐式原型<strong>proto</strong><br>隐式原型指向构造该对象的构造函数的原型</p><h3 id="解构赋值："><a href="#解构赋值：" class="headerlink" title="解构赋值："></a>解构赋值：</h3><p>es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称之为解构赋值。</p><h3 id="数组的解构赋值："><a href="#数组的解构赋值：" class="headerlink" title="数组的解构赋值："></a>数组的解构赋值：</h3><p>只要按照对应的位置进行赋值，我们可以任意嵌套。当然如果等式右边不是数组则会报错，如果解构失败的话，值为undefined</p><h3 id="解构赋值与允许执行默认值"><a href="#解构赋值与允许执行默认值" class="headerlink" title="解构赋值与允许执行默认值"></a>解构赋值与允许执行默认值</h3><p>只有数组的值严格等于undefined，才会被赋予默认值，否则即使是null和false也会被正常赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b=<span class="number">2</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><h3 id="对象的解构赋值："><a href="#对象的解构赋值：" class="headerlink" title="对象的解构赋值："></a>对象的解构赋值：</h3><p>对象的解构赋值和数组的解构赋值的区别在于：数组的元素是按照次序排序的，因此它们赋值也是按照顺序赋值的，但是对象的属性是没有次序的，变量必须与属性同名，才会被赋值。<br>{a:demo} = {a:123};</p><h3 id="解构赋值的作用："><a href="#解构赋值的作用：" class="headerlink" title="解构赋值的作用："></a>解构赋值的作用：</h3><p>1.交换变量：[a,b]=[b,a]<br>2.函数可以有多个返回值：return [1,2,3]<br>3.函数参数的定义：function a({x,y}){}<br>4.获取json数据：let { id, status, data: number } = json;</p><h3 id="promise："><a href="#promise：" class="headerlink" title="promise："></a>promise：</h3><p>用同步的方法去写异步，三种状态 进行 成功 失败<br>在构造函数中决定promise对象的状态，然后通过then方法中传的两个函数，成功的函数和失败的函数进行链式调用（then返回的是一个新的promise对象，构造函数中的内容立即执行）。<br>promise.all()并行执行多个异步操作，传递一个promise对象实例数组，数组中有一个失败则都失败给catch()处理</p><h3 id="promise原理："><a href="#promise原理：" class="headerlink" title="promise原理："></a>promise原理：</h3><p>浏览器中只能有一个事件循环，但是任务队列可以有多个。整个script代码，放在了宏队列中，setTimeout也放入宏队列。但是，promise.then放到了另一个任务队列微队列中。<br>这两个任务队列执行顺序如下（eventloop主要控制逻辑）：<br>1.取1个宏队列中的task，执行之。<br>2.然把所有微队列顺序执行完，再取宏队列中的下一个任务。<br>3.重新渲染UI<br>因此promise.then的回调比setTimeout先执行。而且settimeout(0)<br><img src="/2018/04/22/前端面试总结3/index.png"><br>宏队列可以有多个 微队列只能有一个</p><h3 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h3><p>宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.<br>微任务：process.nextTick, Promise, Object.observer, MutationObserver.</p><h3 id="generator："><a href="#generator：" class="headerlink" title="generator："></a>generator：</h3><p>es6新增的生成器，也是一种异步实现的方案<br>创建 generator 函数，会得到一个 iterator 的 遍历器，可以调用 next() 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test=<span class="keyword">new</span> a();</span><br><span class="line"><span class="built_in">console</span>.log(text.next())<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(text.next())<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(text.next())<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(text.next())<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(text.next())<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator:"></a>iterator:</h3><p>es6新增的遍历器。可以遍历数组，map，set这些结构<br>数组：arrIterator<br>arr<a href="">Symbol.iterator</a><br>map:mapIterator<br>map<a href="">Symbol.iterator</a><br>set:setIterator<br>set<a href="">Symbol.iterator</a><br>注意：数组使用iterator时使用的是实例的对象<a href="">Symbol.iterator</a><br>map和set是使用map，set类型<a href="">Symbol.iterator</a></p><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>1.为什么要防抖和节流：<br>当操作处理函数较为复杂或页面频繁重渲染等操作时，如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕</p><p>2.函数节流:<br>指定时间间隔内只会执行一次任务。<br>原理：函数的节流就是通过闭包保存一个标记（<code>canRun = true</code>），在函数的开头<strong>判断</strong>这个标记是否为 <code>true</code>，如果为 <code>true</code> 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 <code>false</code>，然后把外部传入的函数的执行包在一个 <code>setTimeout</code> 中，最后在 <code>setTimeout</code> 执行完毕后再把标记设置为 <code>true</code>（这里很关键），表示可以执行下一次的循环了。当 <code>setTimeout</code> 还未执行的时候，<code>canRun</code> 这个标记始终为 <code>false</code>，在开头的判断中被 return 掉。</p><p>3.函数防抖:<br>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。<br>原理：通过闭包保存一个标记来保存 <code>setTimeout</code> 返回的值，每当用户输入的时候把前一个 <code>setTimeout</code> clear 掉，然后又创建一个新的 <code>setTimeout</code>，这样就能保证输入字符后的 <code>interval</code> 间隔内如果还有字符输入的话，就不会执行 <code>fn</code> 函数了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js的特点：&quot;&gt;&lt;a href=&quot;#js的特点：&quot; class=&quot;headerlink&quot; title=&quot;js的特点：&quot;&gt;&lt;/a&gt;js的特点：&lt;/h3&gt;&lt;p&gt;脚本语言解释性单线程&lt;br&gt;采用了二进制浮点数表示法，并不能精准的表示0.1这样的简单数字&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>面试总结之网络</title>
    <link href="http://yoursite.com/2018/04/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%932/"/>
    <id>http://yoursite.com/2018/04/22/前端面试总结2/</id>
    <published>2018-04-22T14:03:47.000Z</published>
    <updated>2018-05-15T03:49:34.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AJAX（异步JavaScript和xml）"><a href="#AJAX（异步JavaScript和xml）" class="headerlink" title="AJAX（异步JavaScript和xml）"></a>AJAX（异步JavaScript和xml）</h3><p>XML 指可扩展标记语言，被设计用来传输和存储数据<br>ajax主要就是利用window.xmlhttprequest对象来判断数据请求的状态<br>首先判断请求方法是get还是post，然后用该对象的open方法发送请求<br>通过该对象的readystatechange方法判断readystate==4和status==200是否成功<br>最后用该对象的send方法发送出去</p><h3 id="处理AJAX并发请求："><a href="#处理AJAX并发请求：" class="headerlink" title="处理AJAX并发请求："></a>处理AJAX并发请求：</h3><p>1.串行<br>2.回调计数<br>3.jquery.$deferred() $when(xx).done(fun)</p><h3 id="get和post的区别："><a href="#get和post的区别：" class="headerlink" title="get和post的区别："></a>get和post的区别：</h3><p>get是请求数据，post是提交数据<br>get大小是1024字节，post没有限制<br>post比get安全性高,因为get参数直接暴露在URL上，POST放在Request body中。</p><h3 id="http和https的区别："><a href="#http和https的区别：" class="headerlink" title="http和https的区别："></a>http和https的区别：</h3><p>https比http多了一层ssl安全协议<br>端口号不同<br>https不免费</p><h3 id="HTTP1-0-HTTP1-1-HTTP2-0区别："><a href="#HTTP1-0-HTTP1-1-HTTP2-0区别：" class="headerlink" title="HTTP1.0,HTTP1.1,HTTP2.0区别："></a>HTTP1.0,HTTP1.1,HTTP2.0区别：</h3><p>请求时，1.0只能一个一个发送，1.1串行（长链接），2.0并行（多路复用）<br>1.1和2.0都有首部压缩<br>2.0协议解析为二进制</p><h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><p>客户端向服务端发送SYN数据包(服务端确定客户端发送正常)<br>服务端向客户端发送SYN和ACK<br>(客户端确定服务端发送接受正常，自己发送正常，服务端确认客户端发送正常，自己接受正常)<br>客户端向服务端发送ACK(双方接受发送均正常)</p><h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><p>客户端向服务端发送FIN和ACK<br>服务端像客户端发送ACK<br>服务端断开连接，向客户端发送FIN/ACK<br>客户端返回ACK</p><p>ACK : 确认序号有效<br>SYN : 发起一个新连接<br>FIN ： 释放一个新连接</p><h3 id="TCP和UDP区别："><a href="#TCP和UDP区别：" class="headerlink" title="TCP和UDP区别："></a>TCP和UDP区别：</h3><p>TCP需要建立连接，UDP不需要<br>TCP比UDP可靠<br>UDP比TCP效率高，节约网络开销</p><h3 id="HTTP-amp-TCP-IP"><a href="#HTTP-amp-TCP-IP" class="headerlink" title="HTTP&amp;TCP/IP"></a>HTTP&amp;TCP/IP</h3><p>HTTP 协议 是 TCP / IP 协议 的子集。<br>TCP / IP 分层管理的结构是: 应用层、传输层、网络层、数据链路层。<br>应用层是 HTTP 协议<br>传输层是 TCP 协议<br>网络层是 IP 协议<br>链路层是 网络</p><h3 id="URI-amp-URL"><a href="#URI-amp-URL" class="headerlink" title="URI &amp; URL"></a>URI &amp; URL</h3><p>URI：统一资源标识符<br>URL：统一资源定位符，URL 为 URI 的子集</p><h3 id="在浏览器输入一个-url-都经历了什么？"><a href="#在浏览器输入一个-url-都经历了什么？" class="headerlink" title="在浏览器输入一个 url 都经历了什么？"></a>在浏览器输入一个 url 都经历了什么？</h3><p>浏览器通过 DNS 把域名解析成 ip 地址<br>客户端通过 TCP 协议建立到服务器的 TCP 连接（三次握手）<br>客户端向服务端发送 HTTP 协议包，请求服务器里面的资源文档<br>服务器向客户端发送 HTTP 协议应答包<br>客户端和服务器断开，客户端开始解释处理 HTML 文档</p><h3 id="由于ajax受同源策略的限制："><a href="#由于ajax受同源策略的限制：" class="headerlink" title="由于ajax受同源策略的限制："></a>由于ajax受同源策略的限制：</h3><p>即域名，端口号，协议必须相同，所以ajax不能跨域</p><h3 id="跨域的几种方法："><a href="#跨域的几种方法：" class="headerlink" title="跨域的几种方法："></a>跨域的几种方法：</h3><p>1.jsonp的原理：利用标签的src可跨域性，在url载入成功后执行回调函数获取数据<br>2.document.domain结合iframe标签<br>3.window.name结合iframe<br>4.h5的window.postmassage<br>5.CORS资源共享</p><h3 id="jsonp优缺点："><a href="#jsonp优缺点：" class="headerlink" title="jsonp优缺点："></a>jsonp优缺点：</h3><p>优点：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都 可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。<br>缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。调用失败的时候不会返回各种 HTTP 状态码，安全性不高。</p><h3 id="手动封装jsonp"><a href="#手动封装jsonp" class="headerlink" title="手动封装jsonp"></a>手动封装jsonp</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://localhost:8081/test/true.jsp?cb=callback'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.lastChild);</span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parentNode.removeChild(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="如何实现jsonp的post请求："><a href="#如何实现jsonp的post请求：" class="headerlink" title="如何实现jsonp的post请求："></a>如何实现jsonp的post请求：</h3><p>服务端设置支持跨域<br>主要是Access-Control-Allow-Origin头参数，该参数用来指定允许哪个来源的域请求。服务端代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">'Access-Control-Allow-Origin:*'</span>);<span class="comment">// 表示支持所有来源的域进行请求</span></span><br><span class="line">$data = json_encode(array(<span class="string">"id"</span> =&gt; <span class="string">"1"</span>, <span class="string">"name"</span> =&gt; <span class="string">"tom"</span>));<span class="comment">// 实际在操作过程中可以设置为指定域</span></span><br><span class="line">echo $data;</span><br></pre></td></tr></table></figure></p><h3 id="cookie-session-webstorage："><a href="#cookie-session-webstorage：" class="headerlink" title="cookie/session/webstorage："></a>cookie/session/webstorage：</h3><p>因为http是无状态的协议，所以session在服务端记录用户的状态，cookie在客户端记录用户的一些信息，并且不可跨域，定义在http的header字段中。cookie会存储一个sessionid用来识别session，大小有限制，过期了自动清理，session可以手动设置时间，localStorage会一直保存，需要手动清理，sessionstorage关闭窗口就没了，他俩只存储不会发送</p><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><p>http状态码是表示服务器对请求的响应状态，主要分为以下几个部分<br>1<strong>：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束<br>2</strong>:表示请求成功<br>3<strong>：表示重定向<br>4</strong>：表示客户端错误<br>5**：表示服务器端错误</p><p>100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收<br>200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回。<br>202（Accepted），服务器已接受请求，但尚未处理。<br>204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容<br>205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>206（Partial-Content），服务器已经成功处理了部分 GET 请求。<br>301（Moved-Permanently），永久性重定向<br>302（Moved-Temporarily），暂时性重定向<br>304（Not-Modified），浏览器端缓存的资源依然有效<br>400（Bad-Reques），请求有误，当前请求无法被服务器理解。<br>401（Unauthorized），当前请求需要用户验证。<br>403（Forbidden），服务器已经理解请求，但是拒绝执行它。<br>404（Not-Found），请求的资源没有被找到<br>500（Interval Server Error），服务器内部错误<br>502（Bad GateWay），网关出错<br>503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求。<br>504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AJAX（异步JavaScript和xml）&quot;&gt;&lt;a href=&quot;#AJAX（异步JavaScript和xml）&quot; class=&quot;headerlink&quot; title=&quot;AJAX（异步JavaScript和xml）&quot;&gt;&lt;/a&gt;AJAX（异步JavaScript和xm
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面试总结之html/css</title>
    <link href="http://yoursite.com/2018/04/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/"/>
    <id>http://yoursite.com/2018/04/22/前端面试总结1/</id>
    <published>2018-04-22T13:57:47.000Z</published>
    <updated>2018-05-15T04:21:07.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="行级元素："><a href="#行级元素：" class="headerlink" title="行级元素："></a>行级元素：</h3><p>a b br em span i input 内容决定宽高，不可以改变</p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素:"></a>块级元素:</h3><p>div ul ol h1-h6 table p  占满整行，可以改变宽高</p><h3 id="空元素（void）："><a href="#空元素（void）：" class="headerlink" title="空元素（void）："></a>空元素（void）：</h3><p>area base col command embed link meta keygen param source track wbr 没有关闭的标签（没有/ 没有内容）</p><h3 id="标签的含义"><a href="#标签的含义" class="headerlink" title="标签的含义"></a>标签的含义</h3><p>html告知浏览器其自身是一个 HTML 文档。<br>html标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。文档的头部由head标签定义，而主体由body标签定义。<br>!DOCTYPE声明了文档类型：<br>html5:!DOCTYPE html<br>html:有很多取值<br>document：代表给定浏览器窗口中的html文档。<br>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。</p><h3 id="inline-block："><a href="#inline-block：" class="headerlink" title="inline-block："></a>inline-block：</h3><p>内容决定占位，可以改变宽高</p><h3 id="nodetype的值："><a href="#nodetype的值：" class="headerlink" title="nodetype的值："></a>nodetype的值：</h3><p>元素节点：1<br>属性节点：2<br>文本节点：3</p><h3 id="兼容h5的方法："><a href="#兼容h5的方法：" class="headerlink" title="兼容h5的方法："></a>兼容h5的方法：</h3><p>创建一个以标签名命名的数组，在一个立即执行函数中构造出来所有标签，并设为块级元素</p><h3 id="判断浏览器是否支持css3"><a href="#判断浏览器是否支持css3" class="headerlink" title="判断浏览器是否支持css3:"></a>判断浏览器是否支持css3:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)<span class="comment">//虚拟元素 不添加到dom树中，检测用</span></span><br><span class="line">vendors = <span class="string">'Khtml Ms O Moz Webkit'</span>.split(<span class="string">' '</span>) <span class="comment">//兼容性数组</span></span><br><span class="line">len = vendors.length; </span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">prop</span>) </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> ( prop <span class="keyword">in</span> div.style ) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//如果存在相应属性直接返回true</span></span><br></pre></td></tr></table></figure>  <img src="/2018/04/22/前端面试总结1/index2.png"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   prop = prop.replace(<span class="regexp">/^[a-z]/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;  <span class="comment">//在兼容性写法中首字母是大写的</span></span><br><span class="line">      <span class="keyword">return</span> val.toUpperCase();  </span><br><span class="line">   &#125;);  </span><br><span class="line">   <span class="keyword">while</span>(len--) &#123;  </span><br><span class="line">      <span class="keyword">if</span> ( vendors[len] + prop <span class="keyword">in</span> div.style ) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;         </span><br><span class="line">      &#125;   </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="引入css的几种方式："><a href="#引入css的几种方式：" class="headerlink" title="引入css的几种方式："></a>引入css的几种方式：</h3><p>@import style link 行间</p><h3 id="import和link的区别："><a href="#import和link的区别：" class="headerlink" title="import和link的区别："></a>import和link的区别：</h3><p>1.link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。<br>2.link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>3.link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。<br>4.link支持使用Javascript控制DOM去改变样式；而@import不支持。<br>如果import一个非常重要而且非常大的CSS文件，会对导致闪屏</p><h3 id="css选择器权重："><a href="#css选择器权重：" class="headerlink" title="css选择器权重："></a>css选择器权重：</h3><p>！important        无穷（在ie6中！important不会覆盖下文同一属性的值）<br>行间style          1000<br>id                100<br>class 伪类        10<br>标签 伪元素     1</p><ul><li>0    </li></ul><h3 id="触发bfc的方式：（块级格式化上下文）"><a href="#触发bfc的方式：（块级格式化上下文）" class="headerlink" title="触发bfc的方式：（块级格式化上下文）"></a>触发bfc的方式：（块级格式化上下文）</h3><p>display:inline-block/flex<br>position:absolute/fixed<br>overflow:不为visible<br>float:不为none</p><h3 id="bfc作用："><a href="#bfc作用：" class="headerlink" title="bfc作用："></a>bfc作用：</h3><p>阻止margin塌陷</p><h3 id="margin塌陷合并："><a href="#margin塌陷合并：" class="headerlink" title="margin塌陷合并："></a>margin塌陷合并：</h3><p>垂直合并：上面元素的bottom和下面元素的top会选择大的那个<br>父子塌陷：嵌套元素中，如果设置子元素top，父元素会被top子元素不动</p><h3 id="清除浮动的方法："><a href="#清除浮动的方法：" class="headerlink" title="清除浮动的方法："></a>清除浮动的方法：</h3><p>增加一个空元素clear：both<br>父级加伪类（before、after）clear:both;content:””;display:block;<br>父级：overflow：auto;</p><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height:"></a>line-height:</h3><p>1.对于字号为 16px 的元素，设定 1.5 和 150% 时都会得到 16 × 1.5 = 24px的行高。注意，这里把 font-size 和 line-height 定义在了相同的元素上。<br>2.父元素 div 和子元素 p 被定义了不同的 font-size，而只有父元素 div 被定义了 line-height。<br>当 line-height 取值为百分数时，行高是在 line-height 被定义时计算的，计算成绝对单位值后再被子元素继承。所以在上面的例子中，父元素字号为 16px，相应的子元素行高就是 16 × 1.5 = 24px。因为 24px &lt; 36px，子元素 p 的行高不足，当它以多行显示时会出现文字重叠的现象。<br>当 line-height 取值为小数时，行高是在 font-size 被定义时计算的，计算成绝对单位值后被当前元素应用（不会向下继承）。所以在上面的例子中，父元素字号为 16px，而子元素字号为 36px，相应的行高为 36 × 1.5 = 54px。因为 54px &gt; 36px，子元素 p 的行高大于字号，不会出现多行文字重叠的现象。<br><img src="/2018/04/22/前端面试总结1/index1.png"><br>基线（base line）并不是汉字文字的下端沿，而是英文字母“x”的下端沿</p><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align:"></a>text-align:</h3><p>text-align 属性规定元素中的文本的水平对齐方式。<br>可能的值:<br>left    把文本排列到左边。默认值：由浏览器决定。<br>right    把文本排列到右边。<br>center    把文本排列到中间。<br>justify    实现两端对齐文本效果。<br>inherit    规定应该从父元素继承 text-align 属性的值。</p><h3 id="padding和margin的单位设置为-时，这个-是相对于谁"><a href="#padding和margin的单位设置为-时，这个-是相对于谁" class="headerlink" title="padding和margin的单位设置为%时，这个%是相对于谁"></a>padding和margin的单位设置为%时，这个%是相对于谁</h3><p>当margin设置成百分数的时候，其top right bottom left的值是参照父元素盒子的宽度进行计算</p><h3 id="两栏布局："><a href="#两栏布局：" class="headerlink" title="两栏布局："></a>两栏布局：</h3><p>1.左侧固定：左侧左浮动 右侧margin，宽度100%<br>2.右侧固定：左侧左浮动右侧右浮动，左侧margin-的，左侧宽度100%<br>(在静态元素 并且固定宽时，top 或left的负值是正常人理解的向上或向左x值，而bottom或right的负值是让其下边的兄弟元素向上x值。)</p><h3 id="三栏布局：-中间的标签在最后"><a href="#三栏布局：-中间的标签在最后" class="headerlink" title="三栏布局：(中间的标签在最后)"></a>三栏布局：(中间的标签在最后)</h3><p>1.左右浮动，中间设margin<br>2.左右absolute为0，中间设margin</p><h3 id="水平垂直居中一个元素："><a href="#水平垂直居中一个元素：" class="headerlink" title="水平垂直居中一个元素："></a>水平垂直居中一个元素：</h3><p>1.position：absolute<br>    left：50%；<br>    top：50%；<br>    margin-left：-宽度一半<br>    margin-top：-高度一半<br>2.position：absolute；<br>    margin:auto;<br>    left:0;<br>    right:0;<br>    top:0;<br>    bottom:0;<br>3.position:absolute;<br>    left:50%;<br>    top:50%;<br>    transform:translate(-50%,-50%);<br>4.父级：display：flex；<br>    justify-content：center；</p><h3 id="position的区别："><a href="#position的区别：" class="headerlink" title="position的区别："></a>position的区别：</h3><p>absolute：基于第一个非static的父级定位<br>relative：基于原来位置定位<br>fiexd：相对于视口进行定位（不兼容的话使用js计算滚动的距离手动实现）</p><h3 id="盒模型："><a href="#盒模型：" class="headerlink" title="盒模型："></a>盒模型：</h3><p>1.box-sizing:content-box<br>标准盒模型：<br>width=content的宽度<br>height=content的高度</p><p>2.box-sizing:border-box<br>IE盒子模型特点：<br>width=(border+padding+content)的宽度<br>height=(border+padding+content)的高度</p><h3 id="flex布局（弹性布局）："><a href="#flex布局（弹性布局）：" class="headerlink" title="flex布局（弹性布局）："></a>flex布局（弹性布局）：</h3><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效<br>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员<br>父级元素属性:<br>1.display: flex<br>2.flex-wrap: no-wrap // 超出部分不换行,会压缩子元素<br>3.flex-direction: row（横向排列） || row-reverse（横向倒序排列） || column（纵向排列） || column-reverse（纵向倒序排列）<br>4.flex-flow 为 lex-direction 和 flex-wrap 的复合属性</p><p>子级元素属性:<br>1.flex-grow // 按比例分配剩余空间<br>2.flex-shrink // 按比例收缩超出空间<br>3.flex-basis // 设置伸缩基准值,相当于 width，会覆盖 width。 若基准值总和大于容器宽度，flex-basis 就等于 basis/(basis的总和) * 容器的宽度</p><p>问题：弹性盒子内元素如何水平垂直居中？<br>答案：<br>父级设置以下三个属性<br>1.display: flex;<br>1.justify-content: center;<br>2.align-items: center;</p><h3 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h3><p>当前页面中元素外观发生变化重新渲染</p><h3 id="重排："><a href="#重排：" class="headerlink" title="重排："></a>重排：</h3><p>当前页面dom树结构变化，或者窗口大小变化的，浏览器需要重新排列元素的行为</p><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>将多次重绘重排放到一起</p><h3 id="浏览器渲染过程："><a href="#浏览器渲染过程：" class="headerlink" title="浏览器渲染过程："></a>浏览器渲染过程：</h3><p>获取html，构建dom树<br>根据css构建render树，render树不包含定位和几何信息<br>构建布局树，含有定位和几何信息</p><h3 id="响应式布局："><a href="#响应式布局：" class="headerlink" title="响应式布局："></a>响应式布局：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width"</span> initial-scale=<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>不用绝对宽度用相对的<br>选择加载css<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> media=<span class="string">"screen and (max-device-with:100px)"</span> href=<span class="string">""</span>&gt;</span><br><span class="line">@media screen and (max...)</span><br></pre></td></tr></table></figure></p><h3 id="实现元素拖拽："><a href="#实现元素拖拽：" class="headerlink" title="实现元素拖拽："></a>实现元素拖拽：</h3><p>draggable=”true” 元素可以拖拽<br>dragstart 被拖拽元素 开始时触发<br>dragend 被拖拽元素 结束时触发<br>dragenter 目标元素 拖拽元素进入目标元素<br>dragover 目标元素 拖拽元素在目标元素上移动<br>drop 目标元素 被拖拽的元素在目标元素上同时鼠标放开触发的事件</p><h3 id="h5-requestAnimationFrame"><a href="#h5-requestAnimationFrame" class="headerlink" title="h5 requestAnimationFrame()"></a>h5 requestAnimationFrame()</h3><p>每秒 60 贞，进行运动<br>使用方法：递归调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    requestAnimationFrame(move);</span><br><span class="line">    <span class="comment">// ... 运动代码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animationFrame = requestAnimationFrame(move);</span><br></pre></td></tr></table></figure></p><p>解除:cancelAnimationFrame()</p><h3 id="html5-webStorage-amp-cookie"><a href="#html5-webStorage-amp-cookie" class="headerlink" title="html5 webStorage &amp; cookie"></a>html5 webStorage &amp; cookie</h3><p>localStorage: 存储量在5M以上，浏览器关闭不会失效<br>sessionStorage: 存储量在5M以上，浏览器关闭失效<br>cookie: 存储量不大于4k，过期失效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;行级元素：&quot;&gt;&lt;a href=&quot;#行级元素：&quot; class=&quot;headerlink&quot; title=&quot;行级元素：&quot;&gt;&lt;/a&gt;行级元素：&lt;/h3&gt;&lt;p&gt;a b br em span i input 内容决定宽高，不可以改变&lt;/p&gt;
&lt;h3 id=&quot;块级元素&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>关于bootstrap</title>
    <link href="http://yoursite.com/2018/04/22/%E5%85%B3%E4%BA%8Ebootstrap/"/>
    <id>http://yoursite.com/2018/04/22/关于bootstrap/</id>
    <published>2018-04-22T11:14:47.000Z</published>
    <updated>2018-04-24T10:35:11.246Z</updated>
    
    <content type="html"><![CDATA[<p>1、为什么使用bootstrap？<br>bootstrap是为了移动端而开发的框架，并且可以兼容流行的浏览器，它由规范的CSS，JavaScript插件构成，使用起来非常简单，其最大的优势是响应式布局，CSS媒体查询的功能</p><p>2、什么是bootstrap栅格系统？<br>栅格系统的实现原理，是通过定义容器大小，平分12份，再调整内外边距，最后结合媒体查询，就制作出了强大的响应式网格系统(觉得bootstrap主要就是这个栅格系统了，其他的基本上现用现看文档吧……)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、为什么使用bootstrap？&lt;br&gt;bootstrap是为了移动端而开发的框架，并且可以兼容流行的浏览器，它由规范的CSS，JavaScript插件构成，使用起来非常简单，其最大的优势是响应式布局，CSS媒体查询的功能&lt;/p&gt;
&lt;p&gt;2、什么是bootstrap栅格系
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="bootstrap" scheme="http://yoursite.com/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>有趣的面试题之 一</title>
    <link href="http://yoursite.com/2018/04/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%80/"/>
    <id>http://yoursite.com/2018/04/22/有趣的面试题之一/</id>
    <published>2018-04-22T11:14:47.000Z</published>
    <updated>2018-04-23T13:34:05.542Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个这样的面试题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MAP=&#123;</span><br><span class="line">onclick:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">curry:<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val++ +z</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getInfo=<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> MAP[val]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn=getInfo(<span class="string">"curry"</span>)</span><br><span class="line"><span class="keyword">var</span> a=fn(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">200</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">300</span>))</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">100</span>)(<span class="number">200</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">"curry"</span>)(<span class="number">100</span>)(<span class="number">300</span>))</span><br></pre></td></tr></table></figure></p><p>第一眼看了之后，哇靠什么玩意儿！<br>耐着性子缕了一下，原来是这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn=getInfo(<span class="string">"curry"</span>)</span><br><span class="line"><span class="keyword">var</span> a=fn(<span class="number">100</span>)<span class="comment">//a=getInfo("curry")(100)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getInfo=<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> MAP[val]</span><br><span class="line">&#125;   <span class="comment">//getInfo("curry")=&gt;MAP["curry"]</span></span><br><span class="line">        <span class="comment">//=&gt;fn=MAP.curry</span></span><br><span class="line">        <span class="comment">//=&gt;a=MAP.curry(100)</span></span><br></pre></td></tr></table></figure><p>所以fn就是MAP.curry这个函数<br>a就是MAP.curry(100)<br>接下来我们看MAP.curry这个函数里写了什么<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MAP=&#123;</span><br><span class="line">onclick:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">curry:<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;<span class="comment">//很明显的一个闭包啊！</span></span><br><span class="line"><span class="keyword">return</span> val++ +z<span class="comment">//所以a就是val=100的function (z) &#123;return val++ +z&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道在运算中会遵循这个规则：<br>a++ +b=&gt;(a+b)++<br>而++在后面，只有执行完这一行才能真正加上去<br>在这道题中我们可以知道在这个++还没来得及加上去之后就已经被return了<br>所以a中保存的这个函数中的val=100<br>当a(200)时我们传的参数为200，加上初始100，等于300，然后还有一个val++，这时val=101了。<br>但是因为被return出去了，所以这个后置加加并没有对返回结果造成影响<br>当a(300)是相当于return (101+300)++所以结果为401 val=102<br>当fn(100)(200)相当于val=100,z=200,结果为300（这里为什么没有闭包呢，就是因为fn()的返回值没有被外部接收呀，所以不构成闭包）<br>getInfo(“curry”)(300)相当于只执行了MAP.curry函数，返回值是这个函数<br>所以答案是：<br><img src="/2018/04/22/有趣的面试题之一/answer.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇到一个这样的面试题&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js事件那些事</title>
    <link href="http://yoursite.com/2018/04/22/%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/04/22/事件/</id>
    <published>2018-04-22T11:14:47.000Z</published>
    <updated>2018-04-22T11:54:12.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是事件："><a href="#什么是事件：" class="headerlink" title="什么是事件："></a>什么是事件：</h3><p>事件是交互体验的核心功能</p><h3 id="一．事件冒泡："><a href="#一．事件冒泡：" class="headerlink" title="一．事件冒泡："></a>一．事件冒泡：</h3><p>当一个事件发生时，这个事件会从内向外逐层传递。</p><h3 id="二．为什么会有事件冒泡："><a href="#二．为什么会有事件冒泡：" class="headerlink" title="二．为什么会有事件冒泡："></a>二．为什么会有事件冒泡：</h3><p>因为该事件源本身可能没有处理该事件的能力，所以事件源会把事件交给父级处理</p><h3 id="三．事件捕获："><a href="#三．事件捕获：" class="headerlink" title="三．事件捕获："></a>三．事件捕获：</h3><p>事件捕获和事件冒泡正好是相反的顺序</p><h3 id="标准浏览器："><a href="#标准浏览器：" class="headerlink" title="标准浏览器："></a>标准浏览器：</h3><p>1.Dom.addEventListener(‘click’,function(){},false);</p><p>为dom对象添加一个事件监听器 ，与直接绑定的方式不同 直接绑定的方式 绑定函数只执行一次</p><p>addEventListener()可以多次使用重复执行 这里添加的事件处理程序是在其依副的元素作用域中运行</p><p>第一个参数是事件类型，第二个参数是回调函数（即用来执行的代码），第三个参数默认为false，当改为true时，代表事件捕获；</p><p>2.Dom.removeEventListener(‘click’,function(){});</p><p>为dom对象移除监听器，用addEventListener（）绑定的事件只能用removeEventListener（）解除</p><p>removeEventListener（）第一个参数是事件类型，第二个是要移除的回调函数</p><h3 id="IE浏览器："><a href="#IE浏览器：" class="headerlink" title="IE浏览器："></a>IE浏览器：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dom.attachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">dom.detachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>在使用attachEvent()方法的情况下，事件处理程序在全局作用域下运行，其中的this等于window。并且用attachEvent（）添加的这些事件处理程序不是以添加他们的顺序执行，而是以相反的顺序触发</p><h3 id="语句绑定的方式："><a href="#语句绑定的方式：" class="headerlink" title="语句绑定的方式："></a>语句绑定的方式：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;…&#125;;<span class="comment">//绑定</span></span><br><span class="line"></span><br><span class="line">Btn.onckick-<span class="literal">null</span>;<span class="comment">//解除绑定</span></span><br></pre></td></tr></table></figure><p>eg：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"></span><br><span class="line">addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line"></span><br><span class="line">element.addEventListener(type,handler,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent) &#123;</span><br><span class="line"></span><br><span class="line">element.attachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">element[<span class="string">"on"</span> +type] = handler;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(element.removeEventListener) &#123;</span><br><span class="line"></span><br><span class="line">element.removeEventListener(type,handler,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent) &#123;</span><br><span class="line"></span><br><span class="line">element.detachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">element[<span class="string">"on"</span> +type] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="两种绑定事件的区别："><a href="#两种绑定事件的区别：" class="headerlink" title="两种绑定事件的区别："></a>两种绑定事件的区别：</h3><p>句柄绑定：当前this指向当前节点 支持事件冒泡 不能重复绑定 重复绑定会导致覆盖</p><p>监听器绑定：当前this指向当前元素 支持事件冒泡和捕获 可以重复多次进行事件绑定</p><p>ie事件绑定：当前this不指向当前元素 不支持事件捕获 可以重复多次进行事件绑定</p><h3 id="三．currentTarget与target："><a href="#三．currentTarget与target：" class="headerlink" title="三．currentTarget与target："></a>三．currentTarget与target：</h3><p>currentTarget等于this，target等于当前元素</p><p>例如：点击了button按钮 但是当按钮没有绑定点击事件时该事件便会冒泡到可以处理该事件的父级中（假定是body），那么此时currentTarget=this=body，target=button。</p><p>所以target指向触发事件的对象，currentTarget指向处理事件的对象</p><h3 id="四．标准浏览器和IE浏览器的事件对象："><a href="#四．标准浏览器和IE浏览器的事件对象：" class="headerlink" title="四．标准浏览器和IE浏览器的事件对象："></a>四．标准浏览器和IE浏览器的事件对象：</h3><p>标准浏览器下事件对象是event,打印目标对象：event.target</p><p>IE浏览器下事件对象是window.event，打印目标对象：window.event.srcElement</p><h3 id="五．阻止对象默认行为："><a href="#五．阻止对象默认行为：" class="headerlink" title="五．阻止对象默认行为："></a>五．阻止对象默认行为：</h3><p>标准浏览器：event.preventDefault（）；</p><p>IE浏览器：window.event.returnValue=false;</p><h3 id="六．阻止事件冒泡："><a href="#六．阻止事件冒泡：" class="headerlink" title="六．阻止事件冒泡："></a>六．阻止事件冒泡：</h3><p>标准浏览器：event.stopPropagation();</p><p>IE浏览器：window.event.cancel.Bubble=true；</p><p>Eg：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">varEventUtil = &#123;</span><br><span class="line"></span><br><span class="line">addHandler:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line"></span><br><span class="line">element.addEventListener(type,handler,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;elseif(element.attachEvent) &#123;</span><br><span class="line"></span><br><span class="line">element.attachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">element[<span class="string">"on"</span> +type] = handler;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">removeHandler:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(element.removeEventListener) &#123;</span><br><span class="line"></span><br><span class="line">element.removeEventListener(type,handler,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;elseif(element.detachEvent) &#123;</span><br><span class="line"></span><br><span class="line">element.detachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">element[<span class="string">"on"</span> +type] =<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getEvent:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">returnevent ? event : <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">returnevent.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">preventDefault:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(event.preventDefault) &#123;</span><br><span class="line"></span><br><span class="line">event.preventDefault();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">event.returnValue =<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(event.stopPropagation) &#123;</span><br><span class="line"></span><br><span class="line">event.stopPropagation();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">event.cancelBubble =<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="七．焦点事件："><a href="#七．焦点事件：" class="headerlink" title="七．焦点事件："></a>七．焦点事件：</h3><p>blur：在元素失去焦点时触发，这个事件不会冒泡，所有浏览器都支持。</p><p>foucs：在元素获得焦点时触发，这个事件不会冒泡，所有浏览器都支持。</p><h3 id="八．鼠标事件："><a href="#八．鼠标事件：" class="headerlink" title="八．鼠标事件："></a>八．鼠标事件：</h3><p>1.click事件：在用户单击鼠标按钮或者按下回车键触发；</p><p>2.dblclick事件：在用户双击鼠标按钮时被触发；</p><p>3.mousedown事件：在用户按下了任意鼠标按钮时被触发，mousedown的事件对象中有一个属性叫做button，这个属性的值是0的时候代表我们按下的是左键，1的时候代表按下的中键，2的时候代表按下的是右键。</p><p>4.mouseenter事件：在鼠标光标从元素外部移动到元素范围之内被触发</p><p>5.mousemove事件：当鼠标指针在元素内部移动时重复地触发。</p><p>6.mouseout事件：用户将其移入另一个元素内被触发。</p><p>7.mouseover事件：鼠标指针在元素外部，用户将移入另一个元素的边界时触发，感觉和mouseenter事件类似；</p><p>8.mouseup事件：用户释放鼠标按钮时触发；</p><p>除了mouseenter和mouseleave，所有鼠标事件都会冒泡</p><p>所有的鼠标事件都有clientX和clientY，代表的是鼠标点击的位置，我们可以通过e.clientX和e.clentY来查看。</p><p>Eg：</p><p>拖拽事件的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> disX,</span><br><span class="line"></span><br><span class="line">dixY;</span><br><span class="line"></span><br><span class="line">addEvent(elem, <span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">disX = event.clientX - <span class="built_in">parseInt</span>(getStyle(elem, <span class="string">'left'</span>));</span><br><span class="line"></span><br><span class="line">disY = event.clientY - <span class="built_in">parseInt</span>(getStyle(elem, <span class="string">'top'</span>));</span><br><span class="line"></span><br><span class="line">addEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>, mouseMove);</span><br><span class="line"></span><br><span class="line">addEvent(<span class="built_in">document</span>, <span class="string">'mouseup'</span>, mouseUp);</span><br><span class="line"></span><br><span class="line">stopBubble(e);</span><br><span class="line"></span><br><span class="line">cancelHandler(e);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mouseMove</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">elem.style.left = event.clientX - disX + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">elem.style.top = event.clientY - disY + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mouseUp</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">removeEvent(<span class="built_in">document</span>, <span class="string">'mousemove'</span>, mouseMove);</span><br><span class="line"></span><br><span class="line">removeEvent(<span class="built_in">document</span>, <span class="string">'mouseup'</span>, <span class="built_in">arguments</span>.callee);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九．事件委托："><a href="#九．事件委托：" class="headerlink" title="九．事件委托："></a>九．事件委托：</h3><p>利用事件源对象和事件冒泡来处理的方式就叫做事件委托。</p><h3 id="十．事件委托的优点："><a href="#十．事件委托的优点：" class="headerlink" title="十．事件委托的优点："></a>十．事件委托的优点：</h3><p>1.性能不需要循环所有的子元素一个个绑定事件</p><p>2.灵活当有新的子元素被加入的时候不需要重新绑定事件</p><h3 id="十一-键盘事件："><a href="#十一-键盘事件：" class="headerlink" title="十一.键盘事件："></a>十一.键盘事件：</h3><p>当用户按下键盘时键盘的触发顺序分别是keydown、keypress、keyup。</p><h3 id="keydown和keypress："><a href="#keydown和keypress：" class="headerlink" title="keydown和keypress："></a>keydown和keypress：</h3><p>1.相同点：</p><p>当用户按住键盘不放时两者会一直响应下去</p><p>keyCode和which每个方法都有，表示的是这个键的唯一标示，可以告诉浏览器我们按下的是键盘上的哪一个键，比如空格是32，32就代表空格。不过我们一般都用which，keyCode用的较少。</p><p>2.不同点：</p><p>keydown可以响应所有按键，keypress只响应字符按键（即有ascii码的按键）</p><p>keypress有charCode属性这个属性代表这个字符的ASCII码，配合SHIFT之类的按键可以直接获取大写字母等。</p><p>String上有一个方法叫做fromCharCode，可以接受一个Unicode值（包含ASCII值），然后返回对应的字符串，我们可以配合这个方法和charCode来直接获取输入的字符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是事件：&quot;&gt;&lt;a href=&quot;#什么是事件：&quot; class=&quot;headerlink&quot; title=&quot;什么是事件：&quot;&gt;&lt;/a&gt;什么是事件：&lt;/h3&gt;&lt;p&gt;事件是交互体验的核心功能&lt;/p&gt;
&lt;h3 id=&quot;一．事件冒泡：&quot;&gt;&lt;a href=&quot;#一．事件冒泡：&quot; c
      
    
    </summary>
    
      <category term="js那些事" scheme="http://yoursite.com/categories/js%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>有趣的面试题之 二</title>
    <link href="http://yoursite.com/2018/04/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/04/22/有趣的面试题之二/</id>
    <published>2018-04-22T11:14:47.000Z</published>
    <updated>2018-04-24T08:53:24.370Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name=<span class="string">"oop"</span></span><br><span class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=options.name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Person"</span></span><br><span class="line">Person.prototype.getname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Person(&#123;<span class="attr">name</span>:<span class="string">"jnke"</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor)</span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(p.hasOwnProperty(<span class="string">"name"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(p.hasOwnProperty(<span class="string">"getName"</span>))</span><br><span class="line"><span class="keyword">var</span> getname=p.getname</span><br><span class="line"><span class="built_in">console</span>.log(getname===Person.prototype.getname)</span><br><span class="line"><span class="built_in">console</span>.log(getname())</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.getname())</span><br><span class="line"><span class="built_in">console</span>.log(p.getname())</span><br></pre></td></tr></table></figure><p>这是一个继承问题<br>由于p是由Person构造的，所以p 的构造函数肯定是Person<br>instanceof可以判断一个对象是否是一个类型的实例，也可以判断这个对象的父级中是否继承了一个类型<br>在这里我们通过Person实例的p，所以输出一定是true<br><strong>proto</strong>隐式原型指向构造该对象的构造函数的原型，所以就是person<br>hasOwnProperty判断对象自有属性，name是构造时构造的自有属性，getName是父级共享的<br>p.getname不是自有属性是继承自父级，所以赋值给getname也是引用，所以二者是绝对相等的<br>es5中this指向执行期上下文，window，name=oop<br>由构造函数new出来的对象调用的方法，this指向该对象<br>所以答案：<br><img src="/2018/04/22/有趣的面试题之二/index.png"></p><p>关于变量声明提升的题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;<span class="comment">//箭头函数是匿名函数 属于赋值</span></span><br><span class="line"><span class="keyword">var</span> fn</span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line"><span class="keyword">var</span> fn=<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br></pre></td></tr></table></figure><p>过程是这样的：<br>fn变量声明提升=undefined<br>输出为undefined<br>箭头函数是匿名函数 属于赋值<br>所以输出后fn=()=&gt;{}<br>此时输出为function(){}<br>之后又进行了赋值fn=2<br>输出2<br><img src="/2018/04/22/有趣的面试题之二/index1.png"><br>注意:函数声明不会被变量声明覆盖，但是会被赋值覆盖，所以这里最后输出的fn=2</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于框架/设计模式那些</title>
    <link href="http://yoursite.com/2018/04/22/%E5%85%B6%E4%BB%96/"/>
    <id>http://yoursite.com/2018/04/22/其他/</id>
    <published>2018-04-22T11:14:47.000Z</published>
    <updated>2018-04-28T07:05:18.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git"><a href="#git" class="headerlink" title="git:"></a>git:</h3><p>在创建好的文件夹下使用git init创建版本库<br>使用git add xxx添加文件<br>使用git commit -m ‘xxx’ 添加到仓库<br>git clone xxx 指令，克隆一个本地库</p><h3 id="webpack-模块化方案"><a href="#webpack-模块化方案" class="headerlink" title="webpack:模块化方案"></a>webpack:模块化方案</h3><p>通过require import export model.exprot导入导出来构建模块<br>npm install webpack -g<br>npm init<br>npm install webpack –save-dev<br>npm run build</p><h3 id="gulp：注重工作流程"><a href="#gulp：注重工作流程" class="headerlink" title="gulp：注重工作流程"></a>gulp：注重工作流程</h3><p>require引入 task分配任务，src引入流，pipe执行流，watch监听，dest写入流<br>npm install global gulp<br>npm install –save -dev gulp<br>gulp</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式:"></a>设计模式:</h3><p>工厂模式：定义一个函数，函数中通过传的参数来构造一个对象，并将这个对象返回<br>中介者模式：MVC是中介者模式代表，通过一个中介者将多对多的关系改为一对多的关系<br>强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器<br>观察者模式：发布者和订阅者之间的一对多的关系，当发布者发生变化时，所有订阅者都将受到通知</p><h3 id="vue："><a href="#vue：" class="headerlink" title="vue："></a>vue：</h3><p>el,data,methods,computed,watch,template,props,compoments<br>节点，数据，方法，计算属性，监听，模板，父子传值，组件</p><h2 id="指令："><a href="#指令：" class="headerlink" title="指令："></a>指令：</h2><p>v-bind,v-on,v-model,v-for,v-if，v-once<br>绑定属性，绑定事件，双向绑定，循环dom，判断是否渲染,渲染一次</p><h2 id="vue-cli："><a href="#vue-cli：" class="headerlink" title="vue-cli："></a>vue-cli：</h2><p>官方给的脚手架，用来构建一个vue</p><h3 id="vuex："><a href="#vuex：" class="headerlink" title="vuex："></a>vuex：</h3><p>vue.use(vuex)<br>管理vue组件之间的行为<br>vuex.store({<br>    state:存放组件共享的数据（响应式）<br>    mutations:操作数据方法<br>    actions:异步执行的方法<br>    getter：获取数据<br>})<br>vue({<br>    store<br>})</p><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router:"></a>vue-router:</h3><p><router-link to="">跳转</router-link>to是指定页面目录</p><p><router-view></router-view>渲染<br>path：路径,compontents:组件</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期:"></a>生命周期:</h3><p>八个阶段：<br>        beforeCreate（创建前）el 和 data 并未初始化<br>        created（创建后）data 数据的初始化，el没有<br>        beforeMount(载入前)    完成了 el 和 data 初始化<br>        mounted（载入后）完成挂载<br>        beforeUpdate（更新前）<br>        updated（更新后）<br>        beforeDestroy（销毁前）<br>        destroyed（销毁后）</p><h3 id="MVVM模型："><a href="#MVVM模型：" class="headerlink" title="MVVM模型："></a>MVVM模型：</h3><p>model view view-model，利用了在view-model层双向数据绑定的方式连接model和view模块，view向view-model请求动作，view-model让model响应更新。</p><h3 id="双向数据绑定："><a href="#双向数据绑定：" class="headerlink" title="双向数据绑定："></a>双向数据绑定：</h3><p>vue是通过数据劫持的方式来做数据绑定的，getter、setter对属性进行劫持，当属性值改变是就会notify通知watch对象，而watch对象则会notify到view上对应的位置进行更新（这个地方还没讲清下面再讲），然后我们就看到了视图的更新了，反过来当在视图(如input)输入数据时，也会触发订阅者watch，更新最新的数据到data里面,这样model数据就能实时响应view上的数据变化了，这样一个过程就是数据的双向绑定了。通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git:&quot;&gt;&lt;/a&gt;git:&lt;/h3&gt;&lt;p&gt;在创建好的文件夹下使用git init创建版本库&lt;br&gt;使用git add xxx添加文件&lt;br&gt;使用git commit -m
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
