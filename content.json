{"meta":{"title":"Welcome","subtitle":null,"description":null,"author":"guoziyi","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-04-22T10:57:42.000Z","updated":"2018-04-22T13:49:50.517Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我拥有自己的小窝啦~将会在这里记录前端方面自己总结的知识，还有个人的故事~"},{"title":"categories","date":"2018-04-22T10:57:34.000Z","updated":"2018-04-22T11:52:12.838Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-22T10:57:16.000Z","updated":"2018-04-22T11:51:02.797Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试总结之html/css","slug":"前端面试总结1","date":"2018-04-22T13:57:47.000Z","updated":"2018-04-22T14:02:11.500Z","comments":true,"path":"2018/04/22/前端面试总结1/","link":"","permalink":"http://yoursite.com/2018/04/22/前端面试总结1/","excerpt":"","text":"行级元素：a b br em span i input 内容决定宽高，不可以改变 块级元素:div ul ol h1-h6 table p 占满整行，可以改变宽高 inline-block：内容决定占位，可以改变宽高 nodetype的值：元素节点：1属性节点：2文本节点：3 兼容h5的方法：创建一个以标签名命名的数组，在一个立即执行函数中构造出来所有标签，并设为块级元素 引入css的几种方式：@import style link 行间 css选择器权重：！important 无穷行间style 1000id 100class 伪类 10标签 伪元素 1 0 触发bfc的方式：（块级格式化上下文）display:inline-block/flexposition:absolute/fixedoverflow:不为visiblefloat:不为none bfc作用：阻止margin塌陷 margin塌陷合并：垂直合并：上面元素的bottom和下面元素的top会选择大的那个父子塌陷：嵌套元素中，如果设置子元素top，父元素会被top子元素不动 清除浮动的方法：增加一个空元素clear：both父级加伪类（before、after）clear:both;content:””;display:block;父级：overflow：auto; 两栏布局：1.左侧固定：左侧左浮动 右侧margin，宽度100%2.右侧固定：左侧左浮动右侧右浮动，左侧margin-的，左侧宽度100% 三栏布局：(中间的标签在最后)1.左右浮动，中间设margin2.左右absolute为0，中间设margin 水平垂直居中一个元素：1.position：absolute left：50%； top：50%； margin-left：-宽度一半 margin-top：-高度一半2.position：absolute； margin:auto; left:0; right:0; top:0; bottom:0;3.position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);4.父级：display：flex； justify-content：center； position的区别：absolute：基于第一个非static的父级定位relative：基于原来位置定位fiexd：相对于视口进行定位（不兼容的话使用js计算滚动的距离手动实现） 重绘：当前页面中元素外观发生变化重新渲染 重排：当前页面dom树结构变化，或者窗口大小变化的，浏览器需要重新排列元素的行为 优化：将多次重绘重排放到一起 浏览器渲染过程：获取html，构建dom树根据css构建render树，render树不包含定位和几何信息构建布局树，含有定位和几何信息 响应式布局：不用绝对宽度用相对的选择加载css @media screen and (max…)","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"js事件那些事","slug":"事件","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-22T11:54:12.219Z","comments":true,"path":"2018/04/22/事件/","link":"","permalink":"http://yoursite.com/2018/04/22/事件/","excerpt":"","text":"什么是事件：事件是交互体验的核心功能 一．事件冒泡：当一个事件发生时，这个事件会从内向外逐层传递。 二．为什么会有事件冒泡：因为该事件源本身可能没有处理该事件的能力，所以事件源会把事件交给父级处理 三．事件捕获：事件捕获和事件冒泡正好是相反的顺序 标准浏览器：1.Dom.addEventListener(‘click’,function(){},false); 为dom对象添加一个事件监听器 ，与直接绑定的方式不同 直接绑定的方式 绑定函数只执行一次 addEventListener()可以多次使用重复执行 这里添加的事件处理程序是在其依副的元素作用域中运行 第一个参数是事件类型，第二个参数是回调函数（即用来执行的代码），第三个参数默认为false，当改为true时，代表事件捕获； 2.Dom.removeEventListener(‘click’,function(){}); 为dom对象移除监听器，用addEventListener（）绑定的事件只能用removeEventListener（）解除 removeEventListener（）第一个参数是事件类型，第二个是要移除的回调函数 IE浏览器：123dom.attachEvent(\"onclick\",function()&#123;&#125;)dom.detachEvent(\"onclick\",function()&#123;&#125;) 在使用attachEvent()方法的情况下，事件处理程序在全局作用域下运行，其中的this等于window。并且用attachEvent（）添加的这些事件处理程序不是以添加他们的顺序执行，而是以相反的顺序触发 语句绑定的方式：123Btn.onclick=function()&#123;…&#125;;//绑定Btn.onckick-null;//解除绑定 eg：12345678910111213141516171819202122232425262728293031323334353637383940var EventUtil = &#123;addHandler: function(element,type,handler) &#123;if(element.addEventListener) &#123;element.addEventListener(type,handler,false);&#125;else if(element.attachEvent) &#123;element.attachEvent(\"on\"+type,handler);&#125;else &#123;element[\"on\" +type] = handler;&#125;&#125;,removeHandler: function(element,type,handler)&#123;if(element.removeEventListener) &#123;element.removeEventListener(type,handler,false);&#125;else if(element.detachEvent) &#123;element.detachEvent(\"on\"+type,handler);&#125;else &#123;element[\"on\" +type] = null;&#125;&#125;&#125;; 两种绑定事件的区别：句柄绑定：当前this指向当前节点 支持事件冒泡 不能重复绑定 重复绑定会导致覆盖 监听器绑定：当前this指向当前元素 支持事件冒泡和捕获 可以重复多次进行事件绑定 ie事件绑定：当前this不指向当前元素 不支持事件捕获 可以重复多次进行事件绑定 三．currentTarget与target：currentTarget等于this，target等于当前元素 例如：点击了button按钮 但是当按钮没有绑定点击事件时该事件便会冒泡到可以处理该事件的父级中（假定是body），那么此时currentTarget=this=body，target=button。 所以target指向触发事件的对象，currentTarget指向处理事件的对象 四．标准浏览器和IE浏览器的事件对象：标准浏览器下事件对象是event,打印目标对象：event.target IE浏览器下事件对象是window.event，打印目标对象：window.event.srcElement 五．阻止对象默认行为：标准浏览器：event.preventDefault（）； IE浏览器：window.event.returnValue=false; 六．阻止事件冒泡：标准浏览器：event.stopPropagation(); IE浏览器：window.event.cancel.Bubble=true； Eg：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980varEventUtil = &#123;addHandler:function(element,type,handler) &#123;if(element.addEventListener) &#123;element.addEventListener(type,handler,false);&#125;elseif(element.attachEvent) &#123;element.attachEvent(\"on\"+type,handler);&#125;else&#123;element[\"on\" +type] = handler;&#125;&#125;,removeHandler:function(element,type,handler)&#123;if(element.removeEventListener) &#123;element.removeEventListener(type,handler,false);&#125;elseif(element.detachEvent) &#123;element.detachEvent(\"on\"+type,handler);&#125;else&#123;element[\"on\" +type] =null;&#125;&#125;,getEvent:function(event) &#123;returnevent ? event : window.event;&#125;,getTarget:function(event) &#123;returnevent.target || event.srcElement;&#125;,preventDefault:function(event)&#123;if(event.preventDefault) &#123;event.preventDefault();&#125;else&#123;event.returnValue =false;&#125;&#125;,stopPropagation:function(event) &#123;if(event.stopPropagation) &#123;event.stopPropagation();&#125;else&#123;event.cancelBubble =true;&#125;&#125;&#125;; 七．焦点事件：blur：在元素失去焦点时触发，这个事件不会冒泡，所有浏览器都支持。 foucs：在元素获得焦点时触发，这个事件不会冒泡，所有浏览器都支持。 八．鼠标事件：1.click事件：在用户单击鼠标按钮或者按下回车键触发； 2.dblclick事件：在用户双击鼠标按钮时被触发； 3.mousedown事件：在用户按下了任意鼠标按钮时被触发，mousedown的事件对象中有一个属性叫做button，这个属性的值是0的时候代表我们按下的是左键，1的时候代表按下的中键，2的时候代表按下的是右键。 4.mouseenter事件：在鼠标光标从元素外部移动到元素范围之内被触发 5.mousemove事件：当鼠标指针在元素内部移动时重复地触发。 6.mouseout事件：用户将其移入另一个元素内被触发。 7.mouseover事件：鼠标指针在元素外部，用户将移入另一个元素的边界时触发，感觉和mouseenter事件类似； 8.mouseup事件：用户释放鼠标按钮时触发； 除了mouseenter和mouseleave，所有鼠标事件都会冒泡 所有的鼠标事件都有clientX和clientY，代表的是鼠标点击的位置，我们可以通过e.clientX和e.clentY来查看。 Eg： 拖拽事件的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var div = document.getElementsByTagName('div')[0]function drag(elem) &#123;var disX,dixY;addEvent(elem, 'mousedown', function (e) &#123;var event = e || window.event;disX = event.clientX - parseInt(getStyle(elem, 'left'));disY = event.clientY - parseInt(getStyle(elem, 'top'));addEvent(document, 'mousemove', mouseMove);addEvent(document, 'mouseup', mouseUp);stopBubble(e);cancelHandler(e);&#125;);function mouseMove(e) &#123;var event = e || window.event;elem.style.left = event.clientX - disX + 'px';elem.style.top = event.clientY - disY + 'px';&#125;function mouseUp (e) &#123;removeEvent(document, 'mousemove', mouseMove);removeEvent(document, 'mouseup', arguments.callee);&#125;&#125; 九．事件委托：利用事件源对象和事件冒泡来处理的方式就叫做事件委托。 十．事件委托的优点：1.性能不需要循环所有的子元素一个个绑定事件 2.灵活当有新的子元素被加入的时候不需要重新绑定事件 十一.键盘事件：当用户按下键盘时键盘的触发顺序分别是keydown、keypress、keyup。 keydown和keypress：1.相同点： 当用户按住键盘不放时两者会一直响应下去 keyCode和which每个方法都有，表示的是这个键的唯一标示，可以告诉浏览器我们按下的是键盘上的哪一个键，比如空格是32，32就代表空格。不过我们一般都用which，keyCode用的较少。 2.不同点： keydown可以响应所有按键，keypress只响应字符按键（即有ascii码的按键） keypress有charCode属性这个属性代表这个字符的ASCII码，配合SHIFT之类的按键可以直接获取大写字母等。 String上有一个方法叫做fromCharCode，可以接受一个Unicode值（包含ASCII值），然后返回对应的字符串，我们可以配合这个方法和charCode来直接获取输入的字符。","categories":[{"name":"js那些事","slug":"js那些事","permalink":"http://yoursite.com/categories/js那些事/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]}