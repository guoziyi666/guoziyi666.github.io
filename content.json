{"meta":{"title":"Welcome","subtitle":null,"description":null,"author":"guoziyi","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-04-22T10:57:42.000Z","updated":"2018-04-22T13:49:50.517Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我拥有自己的小窝啦~将会在这里记录前端方面自己总结的知识，还有个人的故事~"},{"title":"categories","date":"2018-04-22T10:57:34.000Z","updated":"2018-04-22T11:52:12.838Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-22T10:57:16.000Z","updated":"2018-04-22T11:51:02.797Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试总结之js","slug":"前端面试总结3","date":"2018-04-22T14:04:47.000Z","updated":"2018-04-22T14:06:47.786Z","comments":true,"path":"2018/04/22/前端面试总结3/","link":"","permalink":"http://yoursite.com/2018/04/22/前端面试总结3/","excerpt":"","text":"js的特点：脚本语言解释性单线程 数据类型：基本类型number string undefined null boolen（在栈中，可以直接访问）引用类型object function array date regexp（在堆中，实际存放了一个指针，操作是对引用的操作） 变量声明提升,函数声明提升：在js中所有声明都会提升在顶部，赋值不提升。函数声明提升在变量声明提升之前，变量声明不会覆盖函数声明。但是赋值会覆盖。 作用域链，闭包作用域链是指js中内部函数可以访问外部函数中的变量，外部不能访问内部。当一个函数执行之前会创建一个对象存储函数的变量，然后挂载在作用域链中。如果一个内部函数被作为一个返回值返回，那么外部函数虽然被销毁了，内部函数却不会被销毁并且依然会保存外部函数执行器上下文，这样就形成了闭包。 闭包的优缺点：优点是由于外部不能访问内部，所以可以设计私有的方法和变量。方便调用上下文变量缺点就是会导致内存泄漏 事件冒泡事件捕获：当一个事件源本身无法处理该事件的时候，会将该事件逐层向外传递就是事件冒泡事件捕获是事件冒泡相反的顺序 事件监听：标准浏览器：addEventListener()/removeEventListener()ie:attachEvent()/detachEvent()句柄绑定：onclick=function（）{} 事件对象和目标对象：标准浏览器：event event.targetie：window.event window.event.srcElementtarget指向触发事件的对象，currentTarget指向处理事件的对象 阻止默认事件：标准：preventDafultie：returnValue=false 阻止事件冒泡：标准：event.stopPropagation()ie:window.event.cancelBubble() 自执行函数js中表达式是立即执行的，如果我们把一个函数变成一个表达式，就是自执行函数，不需要调用直接执行。自执行函数内部作用域受保护，所以一般可以用作命名空间，如jquery。也可以用来处理闭包问题 遍历数组的方法：for,for in,for each(不支持break) 合并数组：…concat 深拷贝浅拷贝（ Object.assign()是浅拷贝）浅拷贝只复制了一层拷贝，即只复制了简单类型深拷贝是层级赋值，遍历所有对象进行复制 箭头函数:箭头函数中的this是定义是所在的对象 匿名函数优缺点：优点：不会污染全局变量缺点：绑定事件时无法解绑 let和constlet:块级作用域只在该块区域有效，可以阻止闭包，会导致暂时性死域（如果有全局的变量同名，那么不论在let前后永远都无法访问全局变量），一个区域不接受同名变量const:声明一个只读的常量，如果是一个对象可以正常的进行添加属性 继承：1.es6中的class extend继承2.原型链：通过new父级构造函数的方式，并且prototype改为父级，这样自己可以访问所有父级的所有属性（浪费）3.用call和apply写构造函数4.共享原型：prototype相同（无法更改，一个改都改了）5.圣杯模型：创建一个空函数，空函数的原型等于父级原型，子级的原型等于new这个空函数。这样两者修改原型不会受影响。修改原型上构造函数为自身，保存一下原型uber为父级 call/apply/bind改变this指向，传参不同（可以实现一个对象调用另一个对象的方法），call一个个传，apply传数组，并且他俩立即执行，bind返回的是一个函数，可以手动执行 DOM/BOM：dom：文档对象模型。将文档当做对象看，用来获取或设置文档中标签的属性。bom：浏览器对象模型。将浏览器当做对象看，用来获取或设置浏览器的属性。 异步方法：1.计时器和回调函数，2.jquery的$deferred() when().done()3.promise4.defer/async异步加载脚本5.generator ：用function*创建函数 yield中写每一步的操作。实例对象.next()执行 原型：prototype是函数的属性，proto是对象的属性。 promise：用同步的方法去写异步，三种状态 进行 成功 失败在构造函数中决定promise对象的状态，然后通过then方法中传的两个函数，成功的函数和失败的函数进行链式调用。promise.all()并行执行多个异步操作，传递一个promise对象实例数组，数组中有一个失败则都失败给catch()处理","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"面试总结之网络","slug":"前端面试总结2","date":"2018-04-22T14:03:47.000Z","updated":"2018-04-22T14:04:20.291Z","comments":true,"path":"2018/04/22/前端面试总结2/","link":"","permalink":"http://yoursite.com/2018/04/22/前端面试总结2/","excerpt":"","text":"AJAX（异步JavaScript和xml）XML 指可扩展标记语言，被设计用来传输和存储数据ajax主要就是利用window.xmlhttprequest对象来判断数据请求的状态首先判断请求方法是get还是post，然后用该对象的open方法发送请求通过该对象的readystatechange方法判断readystate==4和status==200是否成功最后用该对象的send方法发送出去 处理AJAX并发请求：1.串行2.回调计数3.jquery.$deferred() $when(xx).done(fun) get和post的区别：get是请求数据，post是提交数据get大小是1024字节，post没有限制post比get安全性高 http和https的区别：https比http多了一层ssl安全协议端口号不同https不免费 HTTP1.0,HTTP1.1,HTTP2.0区别：请求时，1.0只能一个一个发送，1.1串行（长链接），2.0并行（多路复用）1.1和2.0都有首部压缩2.0协议解析为二进制 三次握手：客户端向服务端发送SYN数据包(服务端确定客户端发送正常)服务端向客户端发送SYN和ACK(客户端确定服务端发送接受正常，自己发送正常，服务端确认客户端发送正常，自己接受正常)客户端向服务端发送ACK(双方接受发送均正常) 四次挥手：客户端向服务端发送FIN和ACK服务端像客户端发送ACK服务端断开连接，向客户端发送FIN/ACK客户端返回ACK TCP和UDP区别：TCP需要建立连接，UDP不需要TCP比UDP可靠UDP比TCP效率高，节约网络开销 由于ajax受同源策略的限制：即域名，端口号，协议必须相同，所以ajax不能跨域 跨域的几种方法：1.jsonp的原理：利用标签的src可跨域性，在url载入成功后执行回调函数获取数据2.document.domain结合iframe标签3.window.name结合iframe4.h5的window.postmassage5.资源共享 cookie/session：因为http是无状态的协议，所以session在服务端记录用户的状态，cookie在客户端记录用户的一些信息，并且不可跨域，定义在http的header字段中。cookie会存储一个sessionid用来识别session，大小有限制，过期了自动清理，localStorage会一直保存，需要手动清理，sessionstorage关闭窗口就没了，他俩只存储不会发送","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"面试总结之html/css","slug":"前端面试总结1","date":"2018-04-22T13:57:47.000Z","updated":"2018-04-23T00:09:57.353Z","comments":true,"path":"2018/04/22/前端面试总结1/","link":"","permalink":"http://yoursite.com/2018/04/22/前端面试总结1/","excerpt":"","text":"行级元素：a b br em span i input 内容决定宽高，不可以改变 块级元素:div ul ol h1-h6 table p 占满整行，可以改变宽高 inline-block：内容决定占位，可以改变宽高 nodetype的值：元素节点：1属性节点：2文本节点：3 兼容h5的方法：创建一个以标签名命名的数组，在一个立即执行函数中构造出来所有标签，并设为块级元素 引入css的几种方式：@import style link 行间 css选择器权重：！important 无穷行间style 1000id 100class 伪类 10标签 伪元素 1 0 触发bfc的方式：（块级格式化上下文）display:inline-block/flexposition:absolute/fixedoverflow:不为visiblefloat:不为none bfc作用：阻止margin塌陷 margin塌陷合并：垂直合并：上面元素的bottom和下面元素的top会选择大的那个父子塌陷：嵌套元素中，如果设置子元素top，父元素会被top子元素不动 清除浮动的方法：增加一个空元素clear：both父级加伪类（before、after）clear:both;content:””;display:block;父级：overflow：auto; 两栏布局：1.左侧固定：左侧左浮动 右侧margin，宽度100%2.右侧固定：左侧左浮动右侧右浮动，左侧margin-的，左侧宽度100%在静态元素 并且固定宽时，top 或left的负值是正常人理解的向上或向左x值，而bottom或right的负值是让其下边的兄弟元素向上x值。 三栏布局：(中间的标签在最后)1.左右浮动，中间设margin2.左右absolute为0，中间设margin 水平垂直居中一个元素：1.position：absolute left：50%； top：50%； margin-left：-宽度一半 margin-top：-高度一半2.position：absolute； margin:auto; left:0; right:0; top:0; bottom:0;3.position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);4.父级：display：flex； justify-content：center； position的区别：absolute：基于第一个非static的父级定位relative：基于原来位置定位fiexd：相对于视口进行定位（不兼容的话使用js计算滚动的距离手动实现） 重绘：当前页面中元素外观发生变化重新渲染 重排：当前页面dom树结构变化，或者窗口大小变化的，浏览器需要重新排列元素的行为 优化：将多次重绘重排放到一起 浏览器渲染过程：获取html，构建dom树根据css构建render树，render树不包含定位和几何信息构建布局树，含有定位和几何信息 响应式布局：不用绝对宽度用相对的选择加载css @media screen and (max…)","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"关于框架/设计模式那些","slug":"其他","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-22T14:09:16.392Z","comments":true,"path":"2018/04/22/其他/","link":"","permalink":"http://yoursite.com/2018/04/22/其他/","excerpt":"","text":"git:在创建好的文件夹下使用git init创建版本库使用git add xxx添加文件使用git commit -m ‘xxx’ 添加到仓库git clone xxx 指令，克隆一个本地库 webpack:模块化方案通过require import export model.exprot导入导出来构建模块npm install webpack -gnpm initnpm install webpack –save-devnpm run build gulp：注重工作流程require引入 task分配任务，src引入流，pipe执行流，watch监听，dest写入流npm install global gulpnpm install –save -dev gulpgulp 设计模式:工厂模式：定义一个函数，函数中通过传的参数来构造一个对象，并将这个对象返回中介者模式：MVC是中介者模式代表，通过一个中介者将多对多的关系改为一对多的关系观察者模式：发布者和订阅者之间的一对多的关系，当发布者发生变化时，所有订阅者都将受到通知 vue：el,data,methods,computed,watch,template,props,compoments节点，数据，方法，计算属性，监听，模板，父子传值，组件 指令：v-bind,v-on,v-model,v-for,v-if，v-once绑定属性，绑定事件，双向绑定，循环dom，判断是否渲染,渲染一次 vue-cli：官方给的脚手架，用来构建一个vue vuex：vue.use(vuex)管理vue之间的行为vuex.store({ state:存放组件共享的数据（响应式） mutations:操作数据方法 actions:异步执行的方法 getter：获取数据})vue({ store}) vue-router:跳转to是指定页面目录 渲染path：路径,compontents:组件 生命周期:八个阶段： beforeCreate（创建前）el 和 data 并未初始化 created（创建后）data 数据的初始化，el没有 beforeMount(载入前) 完成了 el 和 data 初始化 mounted（载入后）完成挂载 beforeUpdate（更新前） updated（更新后） beforeDestroy（销毁前） destroyed（销毁后） MVVM模型：model view view-model，利用了在view-model层双向数据绑定的方式连接model和view模块，view向view-model请求动作，view-model让model响应更新。 双向数据绑定：vue是通过数据劫持的方式来做数据绑定的，通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"js事件那些事","slug":"事件","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-22T11:54:12.219Z","comments":true,"path":"2018/04/22/事件/","link":"","permalink":"http://yoursite.com/2018/04/22/事件/","excerpt":"","text":"什么是事件：事件是交互体验的核心功能 一．事件冒泡：当一个事件发生时，这个事件会从内向外逐层传递。 二．为什么会有事件冒泡：因为该事件源本身可能没有处理该事件的能力，所以事件源会把事件交给父级处理 三．事件捕获：事件捕获和事件冒泡正好是相反的顺序 标准浏览器：1.Dom.addEventListener(‘click’,function(){},false); 为dom对象添加一个事件监听器 ，与直接绑定的方式不同 直接绑定的方式 绑定函数只执行一次 addEventListener()可以多次使用重复执行 这里添加的事件处理程序是在其依副的元素作用域中运行 第一个参数是事件类型，第二个参数是回调函数（即用来执行的代码），第三个参数默认为false，当改为true时，代表事件捕获； 2.Dom.removeEventListener(‘click’,function(){}); 为dom对象移除监听器，用addEventListener（）绑定的事件只能用removeEventListener（）解除 removeEventListener（）第一个参数是事件类型，第二个是要移除的回调函数 IE浏览器：123dom.attachEvent(\"onclick\",function()&#123;&#125;)dom.detachEvent(\"onclick\",function()&#123;&#125;) 在使用attachEvent()方法的情况下，事件处理程序在全局作用域下运行，其中的this等于window。并且用attachEvent（）添加的这些事件处理程序不是以添加他们的顺序执行，而是以相反的顺序触发 语句绑定的方式：123Btn.onclick=function()&#123;…&#125;;//绑定Btn.onckick-null;//解除绑定 eg：12345678910111213141516171819202122232425262728293031323334353637383940var EventUtil = &#123;addHandler: function(element,type,handler) &#123;if(element.addEventListener) &#123;element.addEventListener(type,handler,false);&#125;else if(element.attachEvent) &#123;element.attachEvent(\"on\"+type,handler);&#125;else &#123;element[\"on\" +type] = handler;&#125;&#125;,removeHandler: function(element,type,handler)&#123;if(element.removeEventListener) &#123;element.removeEventListener(type,handler,false);&#125;else if(element.detachEvent) &#123;element.detachEvent(\"on\"+type,handler);&#125;else &#123;element[\"on\" +type] = null;&#125;&#125;&#125;; 两种绑定事件的区别：句柄绑定：当前this指向当前节点 支持事件冒泡 不能重复绑定 重复绑定会导致覆盖 监听器绑定：当前this指向当前元素 支持事件冒泡和捕获 可以重复多次进行事件绑定 ie事件绑定：当前this不指向当前元素 不支持事件捕获 可以重复多次进行事件绑定 三．currentTarget与target：currentTarget等于this，target等于当前元素 例如：点击了button按钮 但是当按钮没有绑定点击事件时该事件便会冒泡到可以处理该事件的父级中（假定是body），那么此时currentTarget=this=body，target=button。 所以target指向触发事件的对象，currentTarget指向处理事件的对象 四．标准浏览器和IE浏览器的事件对象：标准浏览器下事件对象是event,打印目标对象：event.target IE浏览器下事件对象是window.event，打印目标对象：window.event.srcElement 五．阻止对象默认行为：标准浏览器：event.preventDefault（）； IE浏览器：window.event.returnValue=false; 六．阻止事件冒泡：标准浏览器：event.stopPropagation(); IE浏览器：window.event.cancel.Bubble=true； Eg：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980varEventUtil = &#123;addHandler:function(element,type,handler) &#123;if(element.addEventListener) &#123;element.addEventListener(type,handler,false);&#125;elseif(element.attachEvent) &#123;element.attachEvent(\"on\"+type,handler);&#125;else&#123;element[\"on\" +type] = handler;&#125;&#125;,removeHandler:function(element,type,handler)&#123;if(element.removeEventListener) &#123;element.removeEventListener(type,handler,false);&#125;elseif(element.detachEvent) &#123;element.detachEvent(\"on\"+type,handler);&#125;else&#123;element[\"on\" +type] =null;&#125;&#125;,getEvent:function(event) &#123;returnevent ? event : window.event;&#125;,getTarget:function(event) &#123;returnevent.target || event.srcElement;&#125;,preventDefault:function(event)&#123;if(event.preventDefault) &#123;event.preventDefault();&#125;else&#123;event.returnValue =false;&#125;&#125;,stopPropagation:function(event) &#123;if(event.stopPropagation) &#123;event.stopPropagation();&#125;else&#123;event.cancelBubble =true;&#125;&#125;&#125;; 七．焦点事件：blur：在元素失去焦点时触发，这个事件不会冒泡，所有浏览器都支持。 foucs：在元素获得焦点时触发，这个事件不会冒泡，所有浏览器都支持。 八．鼠标事件：1.click事件：在用户单击鼠标按钮或者按下回车键触发； 2.dblclick事件：在用户双击鼠标按钮时被触发； 3.mousedown事件：在用户按下了任意鼠标按钮时被触发，mousedown的事件对象中有一个属性叫做button，这个属性的值是0的时候代表我们按下的是左键，1的时候代表按下的中键，2的时候代表按下的是右键。 4.mouseenter事件：在鼠标光标从元素外部移动到元素范围之内被触发 5.mousemove事件：当鼠标指针在元素内部移动时重复地触发。 6.mouseout事件：用户将其移入另一个元素内被触发。 7.mouseover事件：鼠标指针在元素外部，用户将移入另一个元素的边界时触发，感觉和mouseenter事件类似； 8.mouseup事件：用户释放鼠标按钮时触发； 除了mouseenter和mouseleave，所有鼠标事件都会冒泡 所有的鼠标事件都有clientX和clientY，代表的是鼠标点击的位置，我们可以通过e.clientX和e.clentY来查看。 Eg： 拖拽事件的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var div = document.getElementsByTagName('div')[0]function drag(elem) &#123;var disX,dixY;addEvent(elem, 'mousedown', function (e) &#123;var event = e || window.event;disX = event.clientX - parseInt(getStyle(elem, 'left'));disY = event.clientY - parseInt(getStyle(elem, 'top'));addEvent(document, 'mousemove', mouseMove);addEvent(document, 'mouseup', mouseUp);stopBubble(e);cancelHandler(e);&#125;);function mouseMove(e) &#123;var event = e || window.event;elem.style.left = event.clientX - disX + 'px';elem.style.top = event.clientY - disY + 'px';&#125;function mouseUp (e) &#123;removeEvent(document, 'mousemove', mouseMove);removeEvent(document, 'mouseup', arguments.callee);&#125;&#125; 九．事件委托：利用事件源对象和事件冒泡来处理的方式就叫做事件委托。 十．事件委托的优点：1.性能不需要循环所有的子元素一个个绑定事件 2.灵活当有新的子元素被加入的时候不需要重新绑定事件 十一.键盘事件：当用户按下键盘时键盘的触发顺序分别是keydown、keypress、keyup。 keydown和keypress：1.相同点： 当用户按住键盘不放时两者会一直响应下去 keyCode和which每个方法都有，表示的是这个键的唯一标示，可以告诉浏览器我们按下的是键盘上的哪一个键，比如空格是32，32就代表空格。不过我们一般都用which，keyCode用的较少。 2.不同点： keydown可以响应所有按键，keypress只响应字符按键（即有ascii码的按键） keypress有charCode属性这个属性代表这个字符的ASCII码，配合SHIFT之类的按键可以直接获取大写字母等。 String上有一个方法叫做fromCharCode，可以接受一个Unicode值（包含ASCII值），然后返回对应的字符串，我们可以配合这个方法和charCode来直接获取输入的字符。","categories":[{"name":"js那些事","slug":"js那些事","permalink":"http://yoursite.com/categories/js那些事/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]}