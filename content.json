{"meta":{"title":"Welcome","subtitle":null,"description":null,"author":"guoziyi","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-04-22T10:57:34.000Z","updated":"2018-04-22T11:52:12.838Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-04-22T10:57:42.000Z","updated":"2018-04-22T13:49:50.517Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我拥有自己的小窝啦~将会在这里记录前端方面自己总结的知识，还有个人的故事~"},{"title":"标签","date":"2018-04-22T10:57:16.000Z","updated":"2018-04-22T11:51:02.797Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AJAX","slug":"AJAX","date":"2018-04-24T11:29:47.000Z","updated":"2018-04-24T11:31:35.359Z","comments":true,"path":"2018/04/24/AJAX/","link":"","permalink":"http://yoursite.com/2018/04/24/AJAX/","excerpt":"","text":"什么是ajax：AJAX是“Asynchronous JavaScript and XML”的缩写，异步JavaScript和xml","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"}]},{"title":"面试总结之js","slug":"前端面试总结3","date":"2018-04-22T14:04:47.000Z","updated":"2018-05-14T01:35:05.669Z","comments":true,"path":"2018/04/22/前端面试总结3/","link":"","permalink":"http://yoursite.com/2018/04/22/前端面试总结3/","excerpt":"","text":"js的特点：脚本语言解释性单线程 数据类型：基本类型number string undefined null boolen（在栈中，可以直接访问）引用类型object function array date regexp（在堆中，实际存放了一个指针，操作是对引用的操作） 变量声明提升,函数声明提升：在js中所有声明都会提升在顶部，赋值不提升。函数声明提升在变量声明提升之前，变量声明不会覆盖函数声明。但是赋值会覆盖。判断同名函数声明和变量声明在使用前是否有赋值语句 作用域链，闭包作用域链是指js中内部函数可以访问外部函数中的变量，外部不能访问内部。当一个函数执行之前会创建一个对象存储函数的变量，然后挂载在作用域链中。如果一个内部函数被作为一个返回值返回，那么外部函数虽然被销毁了，内部函数却不会被销毁并且依然会保存外部函数执行器上下文，这样就形成了闭包。如果这个函数被返回后但是没有被接收，那么这个闭包也没有意义。 闭包的优缺点：优点是由于外部不能访问内部，所以可以设计私有的方法和变量。方便调用上下文变量缺点就是会导致内存泄漏 事件冒泡事件捕获：当一个事件源本身无法处理该事件的时候，会将该事件逐层向外传递就是事件冒泡事件捕获是事件冒泡相反的顺序 事件监听：标准浏览器：addEventListener()/removeEventListener()第一个参数是事件类型，第二个参数是回调函数（即用来执行的代码），第三个参数默认为false，当改为true时，代表事件捕获；ie:attachEvent()/detachEvent()句柄绑定：onclick=function（）{} 事件对象和目标对象：标准浏览器：event event.targetie：window.event window.event.srcElementtarget指向触发事件的对象，currentTarget指向处理事件的对象 阻止默认事件：标准：preventDafultie：returnValue=false 阻止事件冒泡：标准：event.stopPropagation()ie:window.event.cancelBubble() 获取元素方法：1.getElementById()2.getElementsByClassName()//实时3.getElementsByName()//实时4.getElementBysTagName()//实时5.querySelectorAll()//非实时更新的，如果节点树发生变化，无法更新6.querySelector()//非实时更新的，如果节点树发生变化，无法更新 dom操作element.append/removeChild 向元素添加/删除子节点，作为最后一个子节点。element.first/lastChild 返回元素的首/尾个子元素。element.previous/nextSibling 返回位于相同节点树层级的前/后一个元素。element.childNodes 返回元素子节点的 NodeList。element.parentNode 返回元素的父节点。 自执行函数js中表达式是立即执行的，如果我们把一个函数变成一个表达式，就是自执行函数，不需要调用直接执行。自执行函数内部作用域受保护，所以一般可以用作命名空间，如jquery。也可以用来处理闭包问题 遍历数组的方法：for,for in,for each(不支持break) 合并数组：…concat 数组和伪数组的区别：伪数组只有length属性，不具备数组的方法。用 Array.isArray(arr)判断是否是数组类型 深拷贝浅拷贝（ Object.assign()是浅拷贝）浅拷贝只复制了一层拷贝，即只复制了简单类型深拷贝是层级赋值，遍历所有对象进行复制 ES6新增数据类型：Symbol:避免属性名冲突 保证该变量独一无二。let s=Symbol();(不能使用new)Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是：前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。（Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值） 箭头函数:箭头函数中的this是定义是所在的对象，箭头函数是匿名函数的，所以要注意变量声明提升的问题哦 匿名函数优缺点：优点：不会污染全局变量缺点：绑定事件时无法解绑 let和constlet:块级作用域只在该块区域有效，可以阻止闭包，会导致暂时性死域（如果有全局的变量同名，那么不论在let前后永远都无法访问全局变量），一个区域不接受同名变量1234567var a=3 function n(argument) &#123; console.log(a) let a=4 console.log(a) &#125; n();//undefined undefined const:声明一个只读的常量，如果是一个对象可以正常的进行添加属性 继承：1.es6中的class extend继承2.原型链：通过new父级构造函数的方式，并且prototype改为父级，这样自己可以访问所有父级的所有属性（浪费）123function Father () &#123;&#125;function Son () &#123;&#125;Son.prototype = new Father() 3.用call和apply写构造函数12function Father () &#123;&#125;function Son () &#123;Father.call(this)&#125; 4.共享原型：prototype相同（无法更改，一个改都改了）123function Father () &#123;&#125;function Son () &#123;&#125;Son.prototype = Father.prototype; 5.圣杯模型：创建一个空函数，空函数的原型等于父级原型，子级的原型等于new这个空函数。这样两者修改原型不会受影响。修改原型上构造函数为自身，保存一下原型uber为父级123456789var inherit = (function ()&#123; var F = function()&#123;&#125;; return function (C,P)&#123; F.prototype = P.prototype; C.prototype = new F(); C.prototype.constructor = C; C.prototype.uber = P; &#125;&#125;()); 6.object.create() ：在原型上生成新的对象的实例12function Father () &#123;&#125;var son = Object.create(new Father); call/apply/bind改变this指向，传参不同（可以实现一个对象调用另一个对象的方法），call一个个传，apply传数组，并且他俩立即执行，bind返回的是一个函数，可以手动执行 new是什么？当我们要创建一个对象的实例时。我们要去继承这个对象的原型。那么new的作用就是帮你自动完成4个步骤。①帮你创建一个新对象。var obj = new Object();②帮你绑定原型。obj.proto = Object.prototype 将新对象的proto属性指向构造函数的prototype③帮你将this指向新对象。④帮你return新对象。但在这里注意构造函数是否有返回值。如果构造函数的返回值为基本数据类型（number，string，boolean，undefined，null）则返回临新对象。如果构造函数的返回值为对象类型，则返回这个对象类型。 this是什么？this是Javascript语言的一个关键字它代表函数运行时，自动生成的一个内部对象。 DOM/BOM：dom：文档对象模型。将文档当做对象看，用来获取或设置文档中标签的属性。bom：浏览器对象模型。将浏览器当做对象看，用来获取或设置浏览器的属性。 异步方法：1.计时器和回调函数，2.jquery的$deferred() when().done()3.promise4.defer/async异步加载脚本5.generator ：用function*创建函数 yield中写每一步的操作。实例对象.next()执行 原型：prototype是函数特有的属性，proto是所有对象的属性。js中万物皆对象，所以一切对象都有这个隐式原型proto隐式原型指向构造该对象的构造函数的原型 解构赋值：es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称之为解构赋值。 数组的解构赋值：只要按照对应的位置进行赋值，我们可以任意嵌套。当然如果等式右边不是数组则会报错，如果解构失败的话，值为undefined 解构赋值与允许执行默认值只有数组的值严格等于undefined，才会被赋予默认值，否则即使是null和false也会被正常赋值。1let [a,b=2] = [1]; 对象的解构赋值：对象的解构赋值和数组的解构赋值的区别在于：数组的元素是按照次序排序的，因此它们赋值也是按照顺序赋值的，但是对象的属性是没有次序的，变量必须与属性同名，才会被赋值。{a:demo} = {a:123}; 解构赋值的作用：1.交换变量：[a,b]=[b,a]2.函数可以有多个返回值：return [1,2,3]3.函数参数的定义：function a({x,y}){}4.获取json数据：let { id, status, data: number } = json; promise：用同步的方法去写异步，三种状态 进行 成功 失败在构造函数中决定promise对象的状态，然后通过then方法中传的两个函数，成功的函数和失败的函数进行链式调用（then返回的是一个新的promise对象，构造函数中的内容立即执行）。promise.all()并行执行多个异步操作，传递一个promise对象实例数组，数组中有一个失败则都失败给catch()处理 promise原理：浏览器中只能有一个事件循环，但是任务队列可以有多个。整个script代码，放在了宏队列中，setTimeout也放入宏队列。但是，promise.then放到了另一个任务队列微队列中。这两个任务队列执行顺序如下（eventloop主要控制逻辑）：1.取1个宏队列中的task，执行之。2.然把所有微队列顺序执行完，再取宏队列中的下一个任务。3.重新渲染UI因此promise.then的回调比setTimeout先执行。而且settimeout(0)宏队列可以有多个 微队列只能有一个 宏队列和微队列宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.微任务：process.nextTick, Promise, Object.observer, MutationObserver. generator：es6新增的生成器，也是一种异步实现的方案创建 generator 函数，会得到一个 iterator 的 遍历器，可以调用 next() 方法123456789101112function * a()&#123; yield 1; yield 2; yield 3; return 0;&#125;var test=new a();console.log(text.next())//1console.log(text.next())//2console.log(text.next())//3console.log(text.next())//0console.log(text.next())//undefined iterator:es6新增的遍历器。可以遍历数组，map，set这些结构数组：arrIteratorarrSymbol.iteratormap:mapIteratormapSymbol.iteratorset:setIteratorsetSymbol.iterator注意：数组使用iterator时使用的是实例的对象Symbol.iteratormap和set是使用map，set类型Symbol.iterator 防抖和节流1.为什么要防抖和节流：当操作处理函数较为复杂或页面频繁重渲染等操作时，如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕 2.函数节流:指定时间间隔内只会执行一次任务。原理：函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉。 3.函数防抖:任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。原理：通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"面试总结之网络","slug":"前端面试总结2","date":"2018-04-22T14:03:47.000Z","updated":"2018-05-13T09:48:52.236Z","comments":true,"path":"2018/04/22/前端面试总结2/","link":"","permalink":"http://yoursite.com/2018/04/22/前端面试总结2/","excerpt":"","text":"AJAX（异步JavaScript和xml）XML 指可扩展标记语言，被设计用来传输和存储数据ajax主要就是利用window.xmlhttprequest对象来判断数据请求的状态首先判断请求方法是get还是post，然后用该对象的open方法发送请求通过该对象的readystatechange方法判断readystate==4和status==200是否成功最后用该对象的send方法发送出去 处理AJAX并发请求：1.串行2.回调计数3.jquery.$deferred() $when(xx).done(fun) get和post的区别：get是请求数据，post是提交数据get大小是1024字节，post没有限制post比get安全性高 http和https的区别：https比http多了一层ssl安全协议端口号不同https不免费 HTTP1.0,HTTP1.1,HTTP2.0区别：请求时，1.0只能一个一个发送，1.1串行（长链接），2.0并行（多路复用）1.1和2.0都有首部压缩2.0协议解析为二进制 三次握手：客户端向服务端发送SYN数据包(服务端确定客户端发送正常)服务端向客户端发送SYN和ACK(客户端确定服务端发送接受正常，自己发送正常，服务端确认客户端发送正常，自己接受正常)客户端向服务端发送ACK(双方接受发送均正常) 四次挥手：客户端向服务端发送FIN和ACK服务端像客户端发送ACK服务端断开连接，向客户端发送FIN/ACK客户端返回ACK TCP和UDP区别：TCP需要建立连接，UDP不需要TCP比UDP可靠UDP比TCP效率高，节约网络开销 由于ajax受同源策略的限制：即域名，端口号，协议必须相同，所以ajax不能跨域 跨域的几种方法：1.jsonp的原理：利用标签的src可跨域性，在url载入成功后执行回调函数获取数据2.document.domain结合iframe标签3.window.name结合iframe4.h5的window.postmassage5.资源共享 jsonp优缺点：优点：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都 可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 如何实现jsonp的post请求：服务端设置支持跨域主要是Access-Control-Allow-Origin头参数，该参数用来指定允许哪个来源的域请求。服务端代码如下：123header('Access-Control-Allow-Origin:*');// 表示支持所有来源的域进行请求$data = json_encode(array(\"id\" =&gt; \"1\", \"name\" =&gt; \"tom\"));// 实际在操作过程中可以设置为指定域echo $data; cookie/session/webstorage：因为http是无状态的协议，所以session在服务端记录用户的状态，cookie在客户端记录用户的一些信息，并且不可跨域，定义在http的header字段中。cookie会存储一个sessionid用来识别session，大小有限制，过期了自动清理，session可以手动设置时间，localStorage会一直保存，需要手动清理，sessionstorage关闭窗口就没了，他俩只存储不会发送 http状态码http状态码是表示服务器对请求的响应状态，主要分为以下几个部分1：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束2:表示请求成功3：表示重定向4：表示客户端错误5**：表示服务器端错误 100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回。202（Accepted），服务器已接受请求，但尚未处理。204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。206（Partial-Content），服务器已经成功处理了部分 GET 请求。301（Moved-Permanently），永久性重定向302（Moved-Temporarily），暂时性重定向304（Not-Modified），浏览器端缓存的资源依然有效400（Bad-Reques），请求有误，当前请求无法被服务器理解。401（Unauthorized），当前请求需要用户验证。403（Forbidden），服务器已经理解请求，但是拒绝执行它。404（Not-Found），请求的资源没有被找到500（Interval Server Error），服务器内部错误502（Bad GateWay），网关出错503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求。504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"面试总结之html/css","slug":"前端面试总结1","date":"2018-04-22T13:57:47.000Z","updated":"2018-05-13T07:44:50.189Z","comments":true,"path":"2018/04/22/前端面试总结1/","link":"","permalink":"http://yoursite.com/2018/04/22/前端面试总结1/","excerpt":"","text":"行级元素：a b br em span i input 内容决定宽高，不可以改变 块级元素:div ul ol h1-h6 table p 占满整行，可以改变宽高 空元素（void）：area base col command embed link meta keygen param source track wbr 没有关闭的标签（没有/ 没有内容） 标签的含义html告知浏览器其自身是一个 HTML 文档。html标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。文档的头部由head标签定义，而主体由body标签定义。!DOCTYPE声明了文档类型：html5:!DOCTYPE htmlhtml:有很多取值document：代表给定浏览器窗口中的html文档。Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 inline-block：内容决定占位，可以改变宽高 nodetype的值：元素节点：1属性节点：2文本节点：3 兼容h5的方法：创建一个以标签名命名的数组，在一个立即执行函数中构造出来所有标签，并设为块级元素 引入css的几种方式：@import style link 行间 css选择器权重：！important 无穷行间style 1000id 100class 伪类 10标签 伪元素 1 0 触发bfc的方式：（块级格式化上下文）display:inline-block/flexposition:absolute/fixedoverflow:不为visiblefloat:不为none bfc作用：阻止margin塌陷 margin塌陷合并：垂直合并：上面元素的bottom和下面元素的top会选择大的那个父子塌陷：嵌套元素中，如果设置子元素top，父元素会被top子元素不动 清除浮动的方法：增加一个空元素clear：both父级加伪类（before、after）clear:both;content:””;display:block;父级：overflow：auto; line-height:1.对于字号为 16px 的元素，设定 1.5 和 150% 时都会得到 16 × 1.5 = 24px的行高。注意，这里把 font-size 和 line-height 定义在了相同的元素上。2.父元素 div 和子元素 p 被定义了不同的 font-size，而只有父元素 div 被定义了 line-height。当 line-height 取值为百分数时，行高是在 line-height 被定义时计算的，计算成绝对单位值后再被子元素继承。所以在上面的例子中，父元素字号为 16px，相应的子元素行高就是 16 × 1.5 = 24px。因为 24px &lt; 36px，子元素 p 的行高不足，当它以多行显示时会出现文字重叠的现象。当 line-height 取值为小数时，行高是在 font-size 被定义时计算的，计算成绝对单位值后被当前元素应用（不会向下继承）。所以在上面的例子中，父元素字号为 16px，而子元素字号为 36px，相应的行高为 36 × 1.5 = 54px。因为 54px &gt; 36px，子元素 p 的行高大于字号，不会出现多行文字重叠的现象。基线（base line）并不是汉字文字的下端沿，而是英文字母“x”的下端沿 text-align:text-align 属性规定元素中的文本的水平对齐方式。可能的值:left 把文本排列到左边。默认值：由浏览器决定。right 把文本排列到右边。center 把文本排列到中间。justify 实现两端对齐文本效果。inherit 规定应该从父元素继承 text-align 属性的值。 两栏布局：1.左侧固定：左侧左浮动 右侧margin，宽度100%2.右侧固定：左侧左浮动右侧右浮动，左侧margin-的，左侧宽度100%(在静态元素 并且固定宽时，top 或left的负值是正常人理解的向上或向左x值，而bottom或right的负值是让其下边的兄弟元素向上x值。) 三栏布局：(中间的标签在最后)1.左右浮动，中间设margin2.左右absolute为0，中间设margin 水平垂直居中一个元素：1.position：absolute left：50%； top：50%； margin-left：-宽度一半 margin-top：-高度一半2.position：absolute； margin:auto; left:0; right:0; top:0; bottom:0;3.position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);4.父级：display：flex； justify-content：center； position的区别：absolute：基于第一个非static的父级定位relative：基于原来位置定位fiexd：相对于视口进行定位（不兼容的话使用js计算滚动的距离手动实现） 盒模型：1.box-sizing:content-box在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)2.box-sizing:border-box在怪异模式下，一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值） flex布局（弹性布局）：注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员父级元素属性:1.display: flex2.flex-wrap: no-wrap // 超出部分不换行,会压缩子元素3.flex-direction: row（横向排列） || row-reverse（横向倒序排列） || column（纵向排列） || column-reverse（纵向倒序排列）4.flex-flow 为 lex-direction 和 flex-wrap 的复合属性 子级元素属性:1.flex-grow // 按比例分配剩余空间2.flex-shrink // 按比例收缩超出空间3.flex-basis // 设置伸缩基准值,相当于 width，会覆盖 width。 若基准值总和大于容器宽度，flex-basis 就等于 basis/(basis的总和) * 容器的宽度 问题：弹性盒子内元素如何水平垂直居中？答案：父级设置以下三个属性1.display: flex;1.justify-content: center;2.align-items: center; 重绘：当前页面中元素外观发生变化重新渲染 重排：当前页面dom树结构变化，或者窗口大小变化的，浏览器需要重新排列元素的行为 优化：将多次重绘重排放到一起 浏览器渲染过程：获取html，构建dom树根据css构建render树，render树不包含定位和几何信息构建布局树，含有定位和几何信息 响应式布局：1&lt;meta name=\"viewport\" content=\"width=device-width\" initial-scale=1&gt; 不用绝对宽度用相对的选择加载css12&lt;link rel=\"stylesheet\" media=\"screen and (max-device-with:100px)\" href=\"\"&gt;@media screen and (max...) 实现元素拖拽：draggable=”true” 元素可以拖拽dragstart 被拖拽元素 开始时触发dragend 被拖拽元素 结束时触发dragenter 目标元素 拖拽元素进入目标元素dragover 目标元素 拖拽元素在目标元素上移动drop 目标元素 被拖拽的元素在目标元素上同时鼠标放开触发的事件 h5 requestAnimationFrame()每秒 60 贞，进行运动使用方法：递归调用12345function move()&#123; requestAnimationFrame(move); // ... 运动代码&#125;;var animationFrame = requestAnimationFrame(move); 解除:cancelAnimationFrame() html5 webStorage &amp; cookielocalStorage: 存储量在5M以上，浏览器关闭不会失效sessionStorage: 存储量在5M以上，浏览器关闭失效cookie: 存储量不大于4k，过期失效 import和link的区别：1.link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。2.link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。3.link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。4.link支持使用Javascript控制DOM去改变样式；而@import不支持。如果import一个非常重要而且非常大的CSS文件，会对导致闪屏","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"关于bootstrap","slug":"关于bootstrap","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-24T10:35:11.246Z","comments":true,"path":"2018/04/22/关于bootstrap/","link":"","permalink":"http://yoursite.com/2018/04/22/关于bootstrap/","excerpt":"","text":"1、为什么使用bootstrap？bootstrap是为了移动端而开发的框架，并且可以兼容流行的浏览器，它由规范的CSS，JavaScript插件构成，使用起来非常简单，其最大的优势是响应式布局，CSS媒体查询的功能 2、什么是bootstrap栅格系统？栅格系统的实现原理，是通过定义容器大小，平分12份，再调整内外边距，最后结合媒体查询，就制作出了强大的响应式网格系统(觉得bootstrap主要就是这个栅格系统了，其他的基本上现用现看文档吧……)","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"}]},{"title":"js事件那些事","slug":"事件","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-22T11:54:12.219Z","comments":true,"path":"2018/04/22/事件/","link":"","permalink":"http://yoursite.com/2018/04/22/事件/","excerpt":"","text":"什么是事件：事件是交互体验的核心功能 一．事件冒泡：当一个事件发生时，这个事件会从内向外逐层传递。 二．为什么会有事件冒泡：因为该事件源本身可能没有处理该事件的能力，所以事件源会把事件交给父级处理 三．事件捕获：事件捕获和事件冒泡正好是相反的顺序 标准浏览器：1.Dom.addEventListener(‘click’,function(){},false); 为dom对象添加一个事件监听器 ，与直接绑定的方式不同 直接绑定的方式 绑定函数只执行一次 addEventListener()可以多次使用重复执行 这里添加的事件处理程序是在其依副的元素作用域中运行 第一个参数是事件类型，第二个参数是回调函数（即用来执行的代码），第三个参数默认为false，当改为true时，代表事件捕获； 2.Dom.removeEventListener(‘click’,function(){}); 为dom对象移除监听器，用addEventListener（）绑定的事件只能用removeEventListener（）解除 removeEventListener（）第一个参数是事件类型，第二个是要移除的回调函数 IE浏览器：123dom.attachEvent(\"onclick\",function()&#123;&#125;)dom.detachEvent(\"onclick\",function()&#123;&#125;) 在使用attachEvent()方法的情况下，事件处理程序在全局作用域下运行，其中的this等于window。并且用attachEvent（）添加的这些事件处理程序不是以添加他们的顺序执行，而是以相反的顺序触发 语句绑定的方式：123Btn.onclick=function()&#123;…&#125;;//绑定Btn.onckick-null;//解除绑定 eg：12345678910111213141516171819202122232425262728293031323334353637383940var EventUtil = &#123;addHandler: function(element,type,handler) &#123;if(element.addEventListener) &#123;element.addEventListener(type,handler,false);&#125;else if(element.attachEvent) &#123;element.attachEvent(\"on\"+type,handler);&#125;else &#123;element[\"on\" +type] = handler;&#125;&#125;,removeHandler: function(element,type,handler)&#123;if(element.removeEventListener) &#123;element.removeEventListener(type,handler,false);&#125;else if(element.detachEvent) &#123;element.detachEvent(\"on\"+type,handler);&#125;else &#123;element[\"on\" +type] = null;&#125;&#125;&#125;; 两种绑定事件的区别：句柄绑定：当前this指向当前节点 支持事件冒泡 不能重复绑定 重复绑定会导致覆盖 监听器绑定：当前this指向当前元素 支持事件冒泡和捕获 可以重复多次进行事件绑定 ie事件绑定：当前this不指向当前元素 不支持事件捕获 可以重复多次进行事件绑定 三．currentTarget与target：currentTarget等于this，target等于当前元素 例如：点击了button按钮 但是当按钮没有绑定点击事件时该事件便会冒泡到可以处理该事件的父级中（假定是body），那么此时currentTarget=this=body，target=button。 所以target指向触发事件的对象，currentTarget指向处理事件的对象 四．标准浏览器和IE浏览器的事件对象：标准浏览器下事件对象是event,打印目标对象：event.target IE浏览器下事件对象是window.event，打印目标对象：window.event.srcElement 五．阻止对象默认行为：标准浏览器：event.preventDefault（）； IE浏览器：window.event.returnValue=false; 六．阻止事件冒泡：标准浏览器：event.stopPropagation(); IE浏览器：window.event.cancel.Bubble=true； Eg：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980varEventUtil = &#123;addHandler:function(element,type,handler) &#123;if(element.addEventListener) &#123;element.addEventListener(type,handler,false);&#125;elseif(element.attachEvent) &#123;element.attachEvent(\"on\"+type,handler);&#125;else&#123;element[\"on\" +type] = handler;&#125;&#125;,removeHandler:function(element,type,handler)&#123;if(element.removeEventListener) &#123;element.removeEventListener(type,handler,false);&#125;elseif(element.detachEvent) &#123;element.detachEvent(\"on\"+type,handler);&#125;else&#123;element[\"on\" +type] =null;&#125;&#125;,getEvent:function(event) &#123;returnevent ? event : window.event;&#125;,getTarget:function(event) &#123;returnevent.target || event.srcElement;&#125;,preventDefault:function(event)&#123;if(event.preventDefault) &#123;event.preventDefault();&#125;else&#123;event.returnValue =false;&#125;&#125;,stopPropagation:function(event) &#123;if(event.stopPropagation) &#123;event.stopPropagation();&#125;else&#123;event.cancelBubble =true;&#125;&#125;&#125;; 七．焦点事件：blur：在元素失去焦点时触发，这个事件不会冒泡，所有浏览器都支持。 foucs：在元素获得焦点时触发，这个事件不会冒泡，所有浏览器都支持。 八．鼠标事件：1.click事件：在用户单击鼠标按钮或者按下回车键触发； 2.dblclick事件：在用户双击鼠标按钮时被触发； 3.mousedown事件：在用户按下了任意鼠标按钮时被触发，mousedown的事件对象中有一个属性叫做button，这个属性的值是0的时候代表我们按下的是左键，1的时候代表按下的中键，2的时候代表按下的是右键。 4.mouseenter事件：在鼠标光标从元素外部移动到元素范围之内被触发 5.mousemove事件：当鼠标指针在元素内部移动时重复地触发。 6.mouseout事件：用户将其移入另一个元素内被触发。 7.mouseover事件：鼠标指针在元素外部，用户将移入另一个元素的边界时触发，感觉和mouseenter事件类似； 8.mouseup事件：用户释放鼠标按钮时触发； 除了mouseenter和mouseleave，所有鼠标事件都会冒泡 所有的鼠标事件都有clientX和clientY，代表的是鼠标点击的位置，我们可以通过e.clientX和e.clentY来查看。 Eg： 拖拽事件的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var div = document.getElementsByTagName('div')[0]function drag(elem) &#123;var disX,dixY;addEvent(elem, 'mousedown', function (e) &#123;var event = e || window.event;disX = event.clientX - parseInt(getStyle(elem, 'left'));disY = event.clientY - parseInt(getStyle(elem, 'top'));addEvent(document, 'mousemove', mouseMove);addEvent(document, 'mouseup', mouseUp);stopBubble(e);cancelHandler(e);&#125;);function mouseMove(e) &#123;var event = e || window.event;elem.style.left = event.clientX - disX + 'px';elem.style.top = event.clientY - disY + 'px';&#125;function mouseUp (e) &#123;removeEvent(document, 'mousemove', mouseMove);removeEvent(document, 'mouseup', arguments.callee);&#125;&#125; 九．事件委托：利用事件源对象和事件冒泡来处理的方式就叫做事件委托。 十．事件委托的优点：1.性能不需要循环所有的子元素一个个绑定事件 2.灵活当有新的子元素被加入的时候不需要重新绑定事件 十一.键盘事件：当用户按下键盘时键盘的触发顺序分别是keydown、keypress、keyup。 keydown和keypress：1.相同点： 当用户按住键盘不放时两者会一直响应下去 keyCode和which每个方法都有，表示的是这个键的唯一标示，可以告诉浏览器我们按下的是键盘上的哪一个键，比如空格是32，32就代表空格。不过我们一般都用which，keyCode用的较少。 2.不同点： keydown可以响应所有按键，keypress只响应字符按键（即有ascii码的按键） keypress有charCode属性这个属性代表这个字符的ASCII码，配合SHIFT之类的按键可以直接获取大写字母等。 String上有一个方法叫做fromCharCode，可以接受一个Unicode值（包含ASCII值），然后返回对应的字符串，我们可以配合这个方法和charCode来直接获取输入的字符。","categories":[{"name":"js那些事","slug":"js那些事","permalink":"http://yoursite.com/categories/js那些事/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"有趣的面试题之 一","slug":"有趣的面试题之一","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-23T13:34:05.542Z","comments":true,"path":"2018/04/22/有趣的面试题之一/","link":"","permalink":"http://yoursite.com/2018/04/22/有趣的面试题之一/","excerpt":"","text":"今天遇到一个这样的面试题1234567891011121314151617var MAP=&#123; onclick:function () &#123;&#125;, curry:function (val) &#123; return function (z) &#123; return val++ +z &#125; &#125; &#125; var getInfo=function (val) &#123; return MAP[val] &#125; var fn=getInfo(\"curry\") var a=fn(100) console.log(a(200)) console.log(a(300)) console.log(fn(100)(200)) console.log(getInfo(\"curry\")(100)(300)) 第一眼看了之后，哇靠什么玩意儿！耐着性子缕了一下，原来是这样：12var fn=getInfo(\"curry\")var a=fn(100)//a=getInfo(\"curry\")(100) 12345var getInfo=function (val) &#123; return MAP[val] &#125; //getInfo(\"curry\")=&gt;MAP[\"curry\"] //=&gt;fn=MAP.curry //=&gt;a=MAP.curry(100) 所以fn就是MAP.curry这个函数a就是MAP.curry(100)接下来我们看MAP.curry这个函数里写了什么12345678var MAP=&#123; onclick:function () &#123;&#125;, curry:function (val) &#123; return function (z) &#123;//很明显的一个闭包啊！ return val++ +z//所以a就是val=100的function (z) &#123;return val++ +z&#125; &#125; &#125; &#125; 我们知道在运算中会遵循这个规则：a++ +b=&gt;(a+b)++而++在后面，只有执行完这一行才能真正加上去在这道题中我们可以知道在这个++还没来得及加上去之后就已经被return了所以a中保存的这个函数中的val=100当a(200)时我们传的参数为200，加上初始100，等于300，然后还有一个val++，这时val=101了。但是因为被return出去了，所以这个后置加加并没有对返回结果造成影响当a(300)是相当于return (101+300)++所以结果为401 val=102当fn(100)(200)相当于val=100,z=200,结果为300（这里为什么没有闭包呢，就是因为fn()的返回值没有被外部接收呀，所以不构成闭包）getInfo(“curry”)(300)相当于只执行了MAP.curry函数，返回值是这个函数所以答案是：","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"有趣的面试题之 二","slug":"有趣的面试题之二","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-24T08:53:24.370Z","comments":true,"path":"2018/04/22/有趣的面试题之二/","link":"","permalink":"http://yoursite.com/2018/04/22/有趣的面试题之二/","excerpt":"","text":"1234567891011121314151617181920var name=\"oop\"var Person=function (options) &#123; this.name=options.name&#125;Person.prototype.name = \"Person\"Person.prototype.getname = function() &#123; return this.name&#125;;var p=new Person(&#123;name:\"jnke\"&#125;)console.log(p.constructor)console.log(p instanceof Person)console.log(p.__proto__)console.log(p.hasOwnProperty(\"name\"))console.log(p.hasOwnProperty(\"getName\"))var getname=p.getnameconsole.log(getname===Person.prototype.getname)console.log(getname())console.log(Person.prototype.getname())console.log(p.getname()) 这是一个继承问题由于p是由Person构造的，所以p 的构造函数肯定是Personinstanceof可以判断一个对象是否是一个类型的实例，也可以判断这个对象的父级中是否继承了一个类型在这里我们通过Person实例的p，所以输出一定是trueproto隐式原型指向构造该对象的构造函数的原型，所以就是personhasOwnProperty判断对象自有属性，name是构造时构造的自有属性，getName是父级共享的p.getname不是自有属性是继承自父级，所以赋值给getname也是引用，所以二者是绝对相等的es5中this指向执行期上下文，window，name=oop由构造函数new出来的对象调用的方法，this指向该对象所以答案： 关于变量声明提升的题： 1234567console.log(fn)var fn=()=&gt;&#123;&#125;//箭头函数是匿名函数 属于赋值var fnconsole.log(fn)var fn=2console.log(fn) 过程是这样的：fn变量声明提升=undefined输出为undefined箭头函数是匿名函数 属于赋值所以输出后fn=()=&gt;{}此时输出为function(){}之后又进行了赋值fn=2输出2注意:函数声明不会被变量声明覆盖，但是会被赋值覆盖，所以这里最后输出的fn=2","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"关于框架/设计模式那些","slug":"其他","date":"2018-04-22T11:14:47.000Z","updated":"2018-04-28T07:05:18.930Z","comments":true,"path":"2018/04/22/其他/","link":"","permalink":"http://yoursite.com/2018/04/22/其他/","excerpt":"","text":"git:在创建好的文件夹下使用git init创建版本库使用git add xxx添加文件使用git commit -m ‘xxx’ 添加到仓库git clone xxx 指令，克隆一个本地库 webpack:模块化方案通过require import export model.exprot导入导出来构建模块npm install webpack -gnpm initnpm install webpack –save-devnpm run build gulp：注重工作流程require引入 task分配任务，src引入流，pipe执行流，watch监听，dest写入流npm install global gulpnpm install –save -dev gulpgulp 设计模式:工厂模式：定义一个函数，函数中通过传的参数来构造一个对象，并将这个对象返回中介者模式：MVC是中介者模式代表，通过一个中介者将多对多的关系改为一对多的关系强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器观察者模式：发布者和订阅者之间的一对多的关系，当发布者发生变化时，所有订阅者都将受到通知 vue：el,data,methods,computed,watch,template,props,compoments节点，数据，方法，计算属性，监听，模板，父子传值，组件 指令：v-bind,v-on,v-model,v-for,v-if，v-once绑定属性，绑定事件，双向绑定，循环dom，判断是否渲染,渲染一次 vue-cli：官方给的脚手架，用来构建一个vue vuex：vue.use(vuex)管理vue组件之间的行为vuex.store({ state:存放组件共享的数据（响应式） mutations:操作数据方法 actions:异步执行的方法 getter：获取数据})vue({ store}) vue-router:跳转to是指定页面目录 渲染path：路径,compontents:组件 生命周期:八个阶段： beforeCreate（创建前）el 和 data 并未初始化 created（创建后）data 数据的初始化，el没有 beforeMount(载入前) 完成了 el 和 data 初始化 mounted（载入后）完成挂载 beforeUpdate（更新前） updated（更新后） beforeDestroy（销毁前） destroyed（销毁后） MVVM模型：model view view-model，利用了在view-model层双向数据绑定的方式连接model和view模块，view向view-model请求动作，view-model让model响应更新。 双向数据绑定：vue是通过数据劫持的方式来做数据绑定的，getter、setter对属性进行劫持，当属性值改变是就会notify通知watch对象，而watch对象则会notify到view上对应的位置进行更新（这个地方还没讲清下面再讲），然后我们就看到了视图的更新了，反过来当在视图(如input)输入数据时，也会触发订阅者watch，更新最新的数据到data里面,这样model数据就能实时响应view上的数据变化了，这样一个过程就是数据的双向绑定了。通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]}]}